// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dydxprotocol/indexer/socks/messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dydxprotocol_2findexer_2fsocks_2fmessages_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_dydxprotocol_2findexer_2fsocks_2fmessages_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "dydxprotocol/indexer/protocol/v1/subaccount.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_dydxprotocol_2findexer_2fsocks_2fmessages_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dydxprotocol_2findexer_2fsocks_2fmessages_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_dydxprotocol_2findexer_2fsocks_2fmessages_2eproto;
namespace dydxprotocol {
namespace indexer {
namespace socks {
class CandleMessage;
struct CandleMessageDefaultTypeInternal;
extern CandleMessageDefaultTypeInternal _CandleMessage_default_instance_;
class MarketMessage;
struct MarketMessageDefaultTypeInternal;
extern MarketMessageDefaultTypeInternal _MarketMessage_default_instance_;
class OrderbookMessage;
struct OrderbookMessageDefaultTypeInternal;
extern OrderbookMessageDefaultTypeInternal _OrderbookMessage_default_instance_;
class SubaccountMessage;
struct SubaccountMessageDefaultTypeInternal;
extern SubaccountMessageDefaultTypeInternal _SubaccountMessage_default_instance_;
class TradeMessage;
struct TradeMessageDefaultTypeInternal;
extern TradeMessageDefaultTypeInternal _TradeMessage_default_instance_;
}  // namespace socks
}  // namespace indexer
}  // namespace dydxprotocol
PROTOBUF_NAMESPACE_OPEN
template <>
::dydxprotocol::indexer::socks::CandleMessage* Arena::CreateMaybeMessage<::dydxprotocol::indexer::socks::CandleMessage>(Arena*);
template <>
::dydxprotocol::indexer::socks::MarketMessage* Arena::CreateMaybeMessage<::dydxprotocol::indexer::socks::MarketMessage>(Arena*);
template <>
::dydxprotocol::indexer::socks::OrderbookMessage* Arena::CreateMaybeMessage<::dydxprotocol::indexer::socks::OrderbookMessage>(Arena*);
template <>
::dydxprotocol::indexer::socks::SubaccountMessage* Arena::CreateMaybeMessage<::dydxprotocol::indexer::socks::SubaccountMessage>(Arena*);
template <>
::dydxprotocol::indexer::socks::TradeMessage* Arena::CreateMaybeMessage<::dydxprotocol::indexer::socks::TradeMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace dydxprotocol {
namespace indexer {
namespace socks {
enum CandleMessage_Resolution : int {
  CandleMessage_Resolution_ONE_MINUTE = 0,
  CandleMessage_Resolution_FIVE_MINUTES = 1,
  CandleMessage_Resolution_FIFTEEN_MINUTES = 2,
  CandleMessage_Resolution_THIRTY_MINUTES = 3,
  CandleMessage_Resolution_ONE_HOUR = 4,
  CandleMessage_Resolution_FOUR_HOURS = 5,
  CandleMessage_Resolution_ONE_DAY = 6,
  CandleMessage_Resolution_CandleMessage_Resolution_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CandleMessage_Resolution_CandleMessage_Resolution_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CandleMessage_Resolution_IsValid(int value);
constexpr CandleMessage_Resolution CandleMessage_Resolution_Resolution_MIN = static_cast<CandleMessage_Resolution>(0);
constexpr CandleMessage_Resolution CandleMessage_Resolution_Resolution_MAX = static_cast<CandleMessage_Resolution>(6);
constexpr int CandleMessage_Resolution_Resolution_ARRAYSIZE = 6 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
CandleMessage_Resolution_descriptor();
template <typename T>
const std::string& CandleMessage_Resolution_Name(T value) {
  static_assert(std::is_same<T, CandleMessage_Resolution>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Resolution_Name().");
  return CandleMessage_Resolution_Name(static_cast<CandleMessage_Resolution>(value));
}
template <>
inline const std::string& CandleMessage_Resolution_Name(CandleMessage_Resolution value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<CandleMessage_Resolution_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool CandleMessage_Resolution_Parse(absl::string_view name, CandleMessage_Resolution* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CandleMessage_Resolution>(
      CandleMessage_Resolution_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class OrderbookMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dydxprotocol.indexer.socks.OrderbookMessage) */ {
 public:
  inline OrderbookMessage() : OrderbookMessage(nullptr) {}
  ~OrderbookMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbookMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbookMessage(const OrderbookMessage& from);
  OrderbookMessage(OrderbookMessage&& from) noexcept
    : OrderbookMessage() {
    *this = ::std::move(from);
  }

  inline OrderbookMessage& operator=(const OrderbookMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbookMessage& operator=(OrderbookMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbookMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbookMessage* internal_default_instance() {
    return reinterpret_cast<const OrderbookMessage*>(
               &_OrderbookMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OrderbookMessage& a, OrderbookMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbookMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbookMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbookMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbookMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbookMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbookMessage& from) {
    OrderbookMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbookMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dydxprotocol.indexer.socks.OrderbookMessage";
  }
  protected:
  explicit OrderbookMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentsFieldNumber = 1,
    kClobPairIdFieldNumber = 2,
    kVersionFieldNumber = 3,
  };
  // string contents = 1;
  void clear_contents() ;
  const std::string& contents() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contents(Arg_&& arg, Args_... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* ptr);

  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(
      const std::string& value);
  std::string* _internal_mutable_contents();

  public:
  // string clob_pair_id = 2;
  void clear_clob_pair_id() ;
  const std::string& clob_pair_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clob_pair_id(Arg_&& arg, Args_... args);
  std::string* mutable_clob_pair_id();
  PROTOBUF_NODISCARD std::string* release_clob_pair_id();
  void set_allocated_clob_pair_id(std::string* ptr);

  private:
  const std::string& _internal_clob_pair_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clob_pair_id(
      const std::string& value);
  std::string* _internal_mutable_clob_pair_id();

  public:
  // string version = 3;
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // @@protoc_insertion_point(class_scope:dydxprotocol.indexer.socks.OrderbookMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clob_pair_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dydxprotocol_2findexer_2fsocks_2fmessages_2eproto;
};// -------------------------------------------------------------------

class SubaccountMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dydxprotocol.indexer.socks.SubaccountMessage) */ {
 public:
  inline SubaccountMessage() : SubaccountMessage(nullptr) {}
  ~SubaccountMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountMessage(const SubaccountMessage& from);
  SubaccountMessage(SubaccountMessage&& from) noexcept
    : SubaccountMessage() {
    *this = ::std::move(from);
  }

  inline SubaccountMessage& operator=(const SubaccountMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountMessage& operator=(SubaccountMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountMessage* internal_default_instance() {
    return reinterpret_cast<const SubaccountMessage*>(
               &_SubaccountMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SubaccountMessage& a, SubaccountMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountMessage& from) {
    SubaccountMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dydxprotocol.indexer.socks.SubaccountMessage";
  }
  protected:
  explicit SubaccountMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockHeightFieldNumber = 1,
    kContentsFieldNumber = 4,
    kVersionFieldNumber = 6,
    kSubaccountIdFieldNumber = 5,
    kTransactionIndexFieldNumber = 2,
    kEventIndexFieldNumber = 3,
  };
  // string block_height = 1;
  void clear_block_height() ;
  const std::string& block_height() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_block_height(Arg_&& arg, Args_... args);
  std::string* mutable_block_height();
  PROTOBUF_NODISCARD std::string* release_block_height();
  void set_allocated_block_height(std::string* ptr);

  private:
  const std::string& _internal_block_height() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_height(
      const std::string& value);
  std::string* _internal_mutable_block_height();

  public:
  // string contents = 4;
  void clear_contents() ;
  const std::string& contents() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contents(Arg_&& arg, Args_... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* ptr);

  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(
      const std::string& value);
  std::string* _internal_mutable_contents();

  public:
  // string version = 6;
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId subaccount_id = 5;
  bool has_subaccount_id() const;
  void clear_subaccount_id() ;
  const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId& subaccount_id() const;
  PROTOBUF_NODISCARD ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* release_subaccount_id();
  ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* mutable_subaccount_id();
  void set_allocated_subaccount_id(::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* subaccount_id);
  private:
  const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId& _internal_subaccount_id() const;
  ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* _internal_mutable_subaccount_id();
  public:
  void unsafe_arena_set_allocated_subaccount_id(
      ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* subaccount_id);
  ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* unsafe_arena_release_subaccount_id();
  // int32 transaction_index = 2;
  void clear_transaction_index() ;
  ::int32_t transaction_index() const;
  void set_transaction_index(::int32_t value);

  private:
  ::int32_t _internal_transaction_index() const;
  void _internal_set_transaction_index(::int32_t value);

  public:
  // uint32 event_index = 3;
  void clear_event_index() ;
  ::uint32_t event_index() const;
  void set_event_index(::uint32_t value);

  private:
  ::uint32_t _internal_event_index() const;
  void _internal_set_event_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dydxprotocol.indexer.socks.SubaccountMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_height_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* subaccount_id_;
    ::int32_t transaction_index_;
    ::uint32_t event_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dydxprotocol_2findexer_2fsocks_2fmessages_2eproto;
};// -------------------------------------------------------------------

class TradeMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dydxprotocol.indexer.socks.TradeMessage) */ {
 public:
  inline TradeMessage() : TradeMessage(nullptr) {}
  ~TradeMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradeMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradeMessage(const TradeMessage& from);
  TradeMessage(TradeMessage&& from) noexcept
    : TradeMessage() {
    *this = ::std::move(from);
  }

  inline TradeMessage& operator=(const TradeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeMessage& operator=(TradeMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeMessage* internal_default_instance() {
    return reinterpret_cast<const TradeMessage*>(
               &_TradeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TradeMessage& a, TradeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradeMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradeMessage& from) {
    TradeMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dydxprotocol.indexer.socks.TradeMessage";
  }
  protected:
  explicit TradeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockHeightFieldNumber = 1,
    kContentsFieldNumber = 4,
    kClobPairIdFieldNumber = 5,
    kVersionFieldNumber = 6,
  };
  // string block_height = 1;
  void clear_block_height() ;
  const std::string& block_height() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_block_height(Arg_&& arg, Args_... args);
  std::string* mutable_block_height();
  PROTOBUF_NODISCARD std::string* release_block_height();
  void set_allocated_block_height(std::string* ptr);

  private:
  const std::string& _internal_block_height() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_height(
      const std::string& value);
  std::string* _internal_mutable_block_height();

  public:
  // string contents = 4;
  void clear_contents() ;
  const std::string& contents() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contents(Arg_&& arg, Args_... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* ptr);

  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(
      const std::string& value);
  std::string* _internal_mutable_contents();

  public:
  // string clob_pair_id = 5;
  void clear_clob_pair_id() ;
  const std::string& clob_pair_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clob_pair_id(Arg_&& arg, Args_... args);
  std::string* mutable_clob_pair_id();
  PROTOBUF_NODISCARD std::string* release_clob_pair_id();
  void set_allocated_clob_pair_id(std::string* ptr);

  private:
  const std::string& _internal_clob_pair_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clob_pair_id(
      const std::string& value);
  std::string* _internal_mutable_clob_pair_id();

  public:
  // string version = 6;
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // @@protoc_insertion_point(class_scope:dydxprotocol.indexer.socks.TradeMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_height_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clob_pair_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dydxprotocol_2findexer_2fsocks_2fmessages_2eproto;
};// -------------------------------------------------------------------

class MarketMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dydxprotocol.indexer.socks.MarketMessage) */ {
 public:
  inline MarketMessage() : MarketMessage(nullptr) {}
  ~MarketMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarketMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketMessage(const MarketMessage& from);
  MarketMessage(MarketMessage&& from) noexcept
    : MarketMessage() {
    *this = ::std::move(from);
  }

  inline MarketMessage& operator=(const MarketMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketMessage& operator=(MarketMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketMessage* internal_default_instance() {
    return reinterpret_cast<const MarketMessage*>(
               &_MarketMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MarketMessage& a, MarketMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketMessage& from) {
    MarketMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dydxprotocol.indexer.socks.MarketMessage";
  }
  protected:
  explicit MarketMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentsFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string contents = 1;
  void clear_contents() ;
  const std::string& contents() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contents(Arg_&& arg, Args_... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* ptr);

  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(
      const std::string& value);
  std::string* _internal_mutable_contents();

  public:
  // string version = 2;
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // @@protoc_insertion_point(class_scope:dydxprotocol.indexer.socks.MarketMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dydxprotocol_2findexer_2fsocks_2fmessages_2eproto;
};// -------------------------------------------------------------------

class CandleMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dydxprotocol.indexer.socks.CandleMessage) */ {
 public:
  inline CandleMessage() : CandleMessage(nullptr) {}
  ~CandleMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CandleMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CandleMessage(const CandleMessage& from);
  CandleMessage(CandleMessage&& from) noexcept
    : CandleMessage() {
    *this = ::std::move(from);
  }

  inline CandleMessage& operator=(const CandleMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CandleMessage& operator=(CandleMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CandleMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CandleMessage* internal_default_instance() {
    return reinterpret_cast<const CandleMessage*>(
               &_CandleMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CandleMessage& a, CandleMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CandleMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CandleMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CandleMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CandleMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CandleMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CandleMessage& from) {
    CandleMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CandleMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dydxprotocol.indexer.socks.CandleMessage";
  }
  protected:
  explicit CandleMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Resolution = CandleMessage_Resolution;
  static constexpr Resolution ONE_MINUTE = CandleMessage_Resolution_ONE_MINUTE;
  static constexpr Resolution FIVE_MINUTES = CandleMessage_Resolution_FIVE_MINUTES;
  static constexpr Resolution FIFTEEN_MINUTES = CandleMessage_Resolution_FIFTEEN_MINUTES;
  static constexpr Resolution THIRTY_MINUTES = CandleMessage_Resolution_THIRTY_MINUTES;
  static constexpr Resolution ONE_HOUR = CandleMessage_Resolution_ONE_HOUR;
  static constexpr Resolution FOUR_HOURS = CandleMessage_Resolution_FOUR_HOURS;
  static constexpr Resolution ONE_DAY = CandleMessage_Resolution_ONE_DAY;
  static inline bool Resolution_IsValid(int value) {
    return CandleMessage_Resolution_IsValid(value);
  }
  static constexpr Resolution Resolution_MIN = CandleMessage_Resolution_Resolution_MIN;
  static constexpr Resolution Resolution_MAX = CandleMessage_Resolution_Resolution_MAX;
  static constexpr int Resolution_ARRAYSIZE = CandleMessage_Resolution_Resolution_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Resolution_descriptor() {
    return CandleMessage_Resolution_descriptor();
  }
  template <typename T>
  static inline const std::string& Resolution_Name(T value) {
    return CandleMessage_Resolution_Name(value);
  }
  static inline bool Resolution_Parse(absl::string_view name, Resolution* value) {
    return CandleMessage_Resolution_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentsFieldNumber = 1,
    kClobPairIdFieldNumber = 2,
    kVersionFieldNumber = 4,
    kResolutionFieldNumber = 3,
  };
  // string contents = 1;
  void clear_contents() ;
  const std::string& contents() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contents(Arg_&& arg, Args_... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* ptr);

  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(
      const std::string& value);
  std::string* _internal_mutable_contents();

  public:
  // string clob_pair_id = 2;
  void clear_clob_pair_id() ;
  const std::string& clob_pair_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clob_pair_id(Arg_&& arg, Args_... args);
  std::string* mutable_clob_pair_id();
  PROTOBUF_NODISCARD std::string* release_clob_pair_id();
  void set_allocated_clob_pair_id(std::string* ptr);

  private:
  const std::string& _internal_clob_pair_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clob_pair_id(
      const std::string& value);
  std::string* _internal_mutable_clob_pair_id();

  public:
  // string version = 4;
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // .dydxprotocol.indexer.socks.CandleMessage.Resolution resolution = 3;
  void clear_resolution() ;
  ::dydxprotocol::indexer::socks::CandleMessage_Resolution resolution() const;
  void set_resolution(::dydxprotocol::indexer::socks::CandleMessage_Resolution value);

  private:
  ::dydxprotocol::indexer::socks::CandleMessage_Resolution _internal_resolution() const;
  void _internal_set_resolution(::dydxprotocol::indexer::socks::CandleMessage_Resolution value);

  public:
  // @@protoc_insertion_point(class_scope:dydxprotocol.indexer.socks.CandleMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clob_pair_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    int resolution_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dydxprotocol_2findexer_2fsocks_2fmessages_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// OrderbookMessage

// string contents = 1;
inline void OrderbookMessage::clear_contents() {
  _impl_.contents_.ClearToEmpty();
}
inline const std::string& OrderbookMessage::contents() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.OrderbookMessage.contents)
  return _internal_contents();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderbookMessage::set_contents(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contents_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.OrderbookMessage.contents)
}
inline std::string* OrderbookMessage::mutable_contents() {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.OrderbookMessage.contents)
  return _s;
}
inline const std::string& OrderbookMessage::_internal_contents() const {
  return _impl_.contents_.Get();
}
inline void OrderbookMessage::_internal_set_contents(const std::string& value) {
  ;


  _impl_.contents_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderbookMessage::_internal_mutable_contents() {
  ;
  return _impl_.contents_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderbookMessage::release_contents() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.OrderbookMessage.contents)
  return _impl_.contents_.Release();
}
inline void OrderbookMessage::set_allocated_contents(std::string* value) {
  _impl_.contents_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contents_.IsDefault()) {
          _impl_.contents_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.OrderbookMessage.contents)
}

// string clob_pair_id = 2;
inline void OrderbookMessage::clear_clob_pair_id() {
  _impl_.clob_pair_id_.ClearToEmpty();
}
inline const std::string& OrderbookMessage::clob_pair_id() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.OrderbookMessage.clob_pair_id)
  return _internal_clob_pair_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderbookMessage::set_clob_pair_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.clob_pair_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.OrderbookMessage.clob_pair_id)
}
inline std::string* OrderbookMessage::mutable_clob_pair_id() {
  std::string* _s = _internal_mutable_clob_pair_id();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.OrderbookMessage.clob_pair_id)
  return _s;
}
inline const std::string& OrderbookMessage::_internal_clob_pair_id() const {
  return _impl_.clob_pair_id_.Get();
}
inline void OrderbookMessage::_internal_set_clob_pair_id(const std::string& value) {
  ;


  _impl_.clob_pair_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderbookMessage::_internal_mutable_clob_pair_id() {
  ;
  return _impl_.clob_pair_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderbookMessage::release_clob_pair_id() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.OrderbookMessage.clob_pair_id)
  return _impl_.clob_pair_id_.Release();
}
inline void OrderbookMessage::set_allocated_clob_pair_id(std::string* value) {
  _impl_.clob_pair_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clob_pair_id_.IsDefault()) {
          _impl_.clob_pair_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.OrderbookMessage.clob_pair_id)
}

// string version = 3;
inline void OrderbookMessage::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& OrderbookMessage::version() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.OrderbookMessage.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderbookMessage::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.OrderbookMessage.version)
}
inline std::string* OrderbookMessage::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.OrderbookMessage.version)
  return _s;
}
inline const std::string& OrderbookMessage::_internal_version() const {
  return _impl_.version_.Get();
}
inline void OrderbookMessage::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderbookMessage::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderbookMessage::release_version() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.OrderbookMessage.version)
  return _impl_.version_.Release();
}
inline void OrderbookMessage::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.OrderbookMessage.version)
}

// -------------------------------------------------------------------

// SubaccountMessage

// string block_height = 1;
inline void SubaccountMessage::clear_block_height() {
  _impl_.block_height_.ClearToEmpty();
}
inline const std::string& SubaccountMessage::block_height() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.SubaccountMessage.block_height)
  return _internal_block_height();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountMessage::set_block_height(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.block_height_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.SubaccountMessage.block_height)
}
inline std::string* SubaccountMessage::mutable_block_height() {
  std::string* _s = _internal_mutable_block_height();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.SubaccountMessage.block_height)
  return _s;
}
inline const std::string& SubaccountMessage::_internal_block_height() const {
  return _impl_.block_height_.Get();
}
inline void SubaccountMessage::_internal_set_block_height(const std::string& value) {
  ;


  _impl_.block_height_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountMessage::_internal_mutable_block_height() {
  ;
  return _impl_.block_height_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountMessage::release_block_height() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.SubaccountMessage.block_height)
  return _impl_.block_height_.Release();
}
inline void SubaccountMessage::set_allocated_block_height(std::string* value) {
  _impl_.block_height_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.block_height_.IsDefault()) {
          _impl_.block_height_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.SubaccountMessage.block_height)
}

// int32 transaction_index = 2;
inline void SubaccountMessage::clear_transaction_index() {
  _impl_.transaction_index_ = 0;
}
inline ::int32_t SubaccountMessage::transaction_index() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.SubaccountMessage.transaction_index)
  return _internal_transaction_index();
}
inline void SubaccountMessage::set_transaction_index(::int32_t value) {
  _internal_set_transaction_index(value);
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.SubaccountMessage.transaction_index)
}
inline ::int32_t SubaccountMessage::_internal_transaction_index() const {
  return _impl_.transaction_index_;
}
inline void SubaccountMessage::_internal_set_transaction_index(::int32_t value) {
  ;
  _impl_.transaction_index_ = value;
}

// uint32 event_index = 3;
inline void SubaccountMessage::clear_event_index() {
  _impl_.event_index_ = 0u;
}
inline ::uint32_t SubaccountMessage::event_index() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.SubaccountMessage.event_index)
  return _internal_event_index();
}
inline void SubaccountMessage::set_event_index(::uint32_t value) {
  _internal_set_event_index(value);
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.SubaccountMessage.event_index)
}
inline ::uint32_t SubaccountMessage::_internal_event_index() const {
  return _impl_.event_index_;
}
inline void SubaccountMessage::_internal_set_event_index(::uint32_t value) {
  ;
  _impl_.event_index_ = value;
}

// string contents = 4;
inline void SubaccountMessage::clear_contents() {
  _impl_.contents_.ClearToEmpty();
}
inline const std::string& SubaccountMessage::contents() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.SubaccountMessage.contents)
  return _internal_contents();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountMessage::set_contents(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contents_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.SubaccountMessage.contents)
}
inline std::string* SubaccountMessage::mutable_contents() {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.SubaccountMessage.contents)
  return _s;
}
inline const std::string& SubaccountMessage::_internal_contents() const {
  return _impl_.contents_.Get();
}
inline void SubaccountMessage::_internal_set_contents(const std::string& value) {
  ;


  _impl_.contents_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountMessage::_internal_mutable_contents() {
  ;
  return _impl_.contents_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountMessage::release_contents() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.SubaccountMessage.contents)
  return _impl_.contents_.Release();
}
inline void SubaccountMessage::set_allocated_contents(std::string* value) {
  _impl_.contents_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contents_.IsDefault()) {
          _impl_.contents_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.SubaccountMessage.contents)
}

// .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId subaccount_id = 5;
inline bool SubaccountMessage::has_subaccount_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.subaccount_id_ != nullptr);
  return value;
}
inline const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId& SubaccountMessage::_internal_subaccount_id() const {
  const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* p = _impl_.subaccount_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId&>(
      ::dydxprotocol::indexer::protocol::v1::_IndexerSubaccountId_default_instance_);
}
inline const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId& SubaccountMessage::subaccount_id() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.SubaccountMessage.subaccount_id)
  return _internal_subaccount_id();
}
inline void SubaccountMessage::unsafe_arena_set_allocated_subaccount_id(
    ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* subaccount_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subaccount_id_);
  }
  _impl_.subaccount_id_ = subaccount_id;
  if (subaccount_id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dydxprotocol.indexer.socks.SubaccountMessage.subaccount_id)
}
inline ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* SubaccountMessage::release_subaccount_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* temp = _impl_.subaccount_id_;
  _impl_.subaccount_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* SubaccountMessage::unsafe_arena_release_subaccount_id() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.SubaccountMessage.subaccount_id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* temp = _impl_.subaccount_id_;
  _impl_.subaccount_id_ = nullptr;
  return temp;
}
inline ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* SubaccountMessage::_internal_mutable_subaccount_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.subaccount_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId>(GetArenaForAllocation());
    _impl_.subaccount_id_ = p;
  }
  return _impl_.subaccount_id_;
}
inline ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* SubaccountMessage::mutable_subaccount_id() {
  ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* _msg = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.SubaccountMessage.subaccount_id)
  return _msg;
}
inline void SubaccountMessage::set_allocated_subaccount_id(::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* subaccount_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subaccount_id_);
  }
  if (subaccount_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subaccount_id));
    if (message_arena != submessage_arena) {
      subaccount_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subaccount_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.subaccount_id_ = subaccount_id;
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.SubaccountMessage.subaccount_id)
}

// string version = 6;
inline void SubaccountMessage::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& SubaccountMessage::version() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.SubaccountMessage.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountMessage::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.SubaccountMessage.version)
}
inline std::string* SubaccountMessage::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.SubaccountMessage.version)
  return _s;
}
inline const std::string& SubaccountMessage::_internal_version() const {
  return _impl_.version_.Get();
}
inline void SubaccountMessage::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountMessage::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountMessage::release_version() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.SubaccountMessage.version)
  return _impl_.version_.Release();
}
inline void SubaccountMessage::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.SubaccountMessage.version)
}

// -------------------------------------------------------------------

// TradeMessage

// string block_height = 1;
inline void TradeMessage::clear_block_height() {
  _impl_.block_height_.ClearToEmpty();
}
inline const std::string& TradeMessage::block_height() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.TradeMessage.block_height)
  return _internal_block_height();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeMessage::set_block_height(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.block_height_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.TradeMessage.block_height)
}
inline std::string* TradeMessage::mutable_block_height() {
  std::string* _s = _internal_mutable_block_height();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.TradeMessage.block_height)
  return _s;
}
inline const std::string& TradeMessage::_internal_block_height() const {
  return _impl_.block_height_.Get();
}
inline void TradeMessage::_internal_set_block_height(const std::string& value) {
  ;


  _impl_.block_height_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeMessage::_internal_mutable_block_height() {
  ;
  return _impl_.block_height_.Mutable( GetArenaForAllocation());
}
inline std::string* TradeMessage::release_block_height() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.TradeMessage.block_height)
  return _impl_.block_height_.Release();
}
inline void TradeMessage::set_allocated_block_height(std::string* value) {
  _impl_.block_height_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.block_height_.IsDefault()) {
          _impl_.block_height_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.TradeMessage.block_height)
}

// string contents = 4;
inline void TradeMessage::clear_contents() {
  _impl_.contents_.ClearToEmpty();
}
inline const std::string& TradeMessage::contents() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.TradeMessage.contents)
  return _internal_contents();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeMessage::set_contents(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contents_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.TradeMessage.contents)
}
inline std::string* TradeMessage::mutable_contents() {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.TradeMessage.contents)
  return _s;
}
inline const std::string& TradeMessage::_internal_contents() const {
  return _impl_.contents_.Get();
}
inline void TradeMessage::_internal_set_contents(const std::string& value) {
  ;


  _impl_.contents_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeMessage::_internal_mutable_contents() {
  ;
  return _impl_.contents_.Mutable( GetArenaForAllocation());
}
inline std::string* TradeMessage::release_contents() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.TradeMessage.contents)
  return _impl_.contents_.Release();
}
inline void TradeMessage::set_allocated_contents(std::string* value) {
  _impl_.contents_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contents_.IsDefault()) {
          _impl_.contents_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.TradeMessage.contents)
}

// string clob_pair_id = 5;
inline void TradeMessage::clear_clob_pair_id() {
  _impl_.clob_pair_id_.ClearToEmpty();
}
inline const std::string& TradeMessage::clob_pair_id() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.TradeMessage.clob_pair_id)
  return _internal_clob_pair_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeMessage::set_clob_pair_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.clob_pair_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.TradeMessage.clob_pair_id)
}
inline std::string* TradeMessage::mutable_clob_pair_id() {
  std::string* _s = _internal_mutable_clob_pair_id();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.TradeMessage.clob_pair_id)
  return _s;
}
inline const std::string& TradeMessage::_internal_clob_pair_id() const {
  return _impl_.clob_pair_id_.Get();
}
inline void TradeMessage::_internal_set_clob_pair_id(const std::string& value) {
  ;


  _impl_.clob_pair_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeMessage::_internal_mutable_clob_pair_id() {
  ;
  return _impl_.clob_pair_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TradeMessage::release_clob_pair_id() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.TradeMessage.clob_pair_id)
  return _impl_.clob_pair_id_.Release();
}
inline void TradeMessage::set_allocated_clob_pair_id(std::string* value) {
  _impl_.clob_pair_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clob_pair_id_.IsDefault()) {
          _impl_.clob_pair_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.TradeMessage.clob_pair_id)
}

// string version = 6;
inline void TradeMessage::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& TradeMessage::version() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.TradeMessage.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeMessage::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.TradeMessage.version)
}
inline std::string* TradeMessage::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.TradeMessage.version)
  return _s;
}
inline const std::string& TradeMessage::_internal_version() const {
  return _impl_.version_.Get();
}
inline void TradeMessage::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeMessage::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* TradeMessage::release_version() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.TradeMessage.version)
  return _impl_.version_.Release();
}
inline void TradeMessage::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.TradeMessage.version)
}

// -------------------------------------------------------------------

// MarketMessage

// string contents = 1;
inline void MarketMessage::clear_contents() {
  _impl_.contents_.ClearToEmpty();
}
inline const std::string& MarketMessage::contents() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.MarketMessage.contents)
  return _internal_contents();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketMessage::set_contents(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contents_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.MarketMessage.contents)
}
inline std::string* MarketMessage::mutable_contents() {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.MarketMessage.contents)
  return _s;
}
inline const std::string& MarketMessage::_internal_contents() const {
  return _impl_.contents_.Get();
}
inline void MarketMessage::_internal_set_contents(const std::string& value) {
  ;


  _impl_.contents_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketMessage::_internal_mutable_contents() {
  ;
  return _impl_.contents_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketMessage::release_contents() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.MarketMessage.contents)
  return _impl_.contents_.Release();
}
inline void MarketMessage::set_allocated_contents(std::string* value) {
  _impl_.contents_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contents_.IsDefault()) {
          _impl_.contents_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.MarketMessage.contents)
}

// string version = 2;
inline void MarketMessage::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& MarketMessage::version() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.MarketMessage.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketMessage::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.MarketMessage.version)
}
inline std::string* MarketMessage::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.MarketMessage.version)
  return _s;
}
inline const std::string& MarketMessage::_internal_version() const {
  return _impl_.version_.Get();
}
inline void MarketMessage::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketMessage::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketMessage::release_version() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.MarketMessage.version)
  return _impl_.version_.Release();
}
inline void MarketMessage::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.MarketMessage.version)
}

// -------------------------------------------------------------------

// CandleMessage

// string contents = 1;
inline void CandleMessage::clear_contents() {
  _impl_.contents_.ClearToEmpty();
}
inline const std::string& CandleMessage::contents() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.CandleMessage.contents)
  return _internal_contents();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CandleMessage::set_contents(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contents_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.CandleMessage.contents)
}
inline std::string* CandleMessage::mutable_contents() {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.CandleMessage.contents)
  return _s;
}
inline const std::string& CandleMessage::_internal_contents() const {
  return _impl_.contents_.Get();
}
inline void CandleMessage::_internal_set_contents(const std::string& value) {
  ;


  _impl_.contents_.Set(value, GetArenaForAllocation());
}
inline std::string* CandleMessage::_internal_mutable_contents() {
  ;
  return _impl_.contents_.Mutable( GetArenaForAllocation());
}
inline std::string* CandleMessage::release_contents() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.CandleMessage.contents)
  return _impl_.contents_.Release();
}
inline void CandleMessage::set_allocated_contents(std::string* value) {
  _impl_.contents_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contents_.IsDefault()) {
          _impl_.contents_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.CandleMessage.contents)
}

// string clob_pair_id = 2;
inline void CandleMessage::clear_clob_pair_id() {
  _impl_.clob_pair_id_.ClearToEmpty();
}
inline const std::string& CandleMessage::clob_pair_id() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.CandleMessage.clob_pair_id)
  return _internal_clob_pair_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CandleMessage::set_clob_pair_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.clob_pair_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.CandleMessage.clob_pair_id)
}
inline std::string* CandleMessage::mutable_clob_pair_id() {
  std::string* _s = _internal_mutable_clob_pair_id();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.CandleMessage.clob_pair_id)
  return _s;
}
inline const std::string& CandleMessage::_internal_clob_pair_id() const {
  return _impl_.clob_pair_id_.Get();
}
inline void CandleMessage::_internal_set_clob_pair_id(const std::string& value) {
  ;


  _impl_.clob_pair_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CandleMessage::_internal_mutable_clob_pair_id() {
  ;
  return _impl_.clob_pair_id_.Mutable( GetArenaForAllocation());
}
inline std::string* CandleMessage::release_clob_pair_id() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.CandleMessage.clob_pair_id)
  return _impl_.clob_pair_id_.Release();
}
inline void CandleMessage::set_allocated_clob_pair_id(std::string* value) {
  _impl_.clob_pair_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clob_pair_id_.IsDefault()) {
          _impl_.clob_pair_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.CandleMessage.clob_pair_id)
}

// .dydxprotocol.indexer.socks.CandleMessage.Resolution resolution = 3;
inline void CandleMessage::clear_resolution() {
  _impl_.resolution_ = 0;
}
inline ::dydxprotocol::indexer::socks::CandleMessage_Resolution CandleMessage::resolution() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.CandleMessage.resolution)
  return _internal_resolution();
}
inline void CandleMessage::set_resolution(::dydxprotocol::indexer::socks::CandleMessage_Resolution value) {
   _internal_set_resolution(value);
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.CandleMessage.resolution)
}
inline ::dydxprotocol::indexer::socks::CandleMessage_Resolution CandleMessage::_internal_resolution() const {
  return static_cast<::dydxprotocol::indexer::socks::CandleMessage_Resolution>(_impl_.resolution_);
}
inline void CandleMessage::_internal_set_resolution(::dydxprotocol::indexer::socks::CandleMessage_Resolution value) {
  ;
  _impl_.resolution_ = value;
}

// string version = 4;
inline void CandleMessage::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& CandleMessage::version() const {
  // @@protoc_insertion_point(field_get:dydxprotocol.indexer.socks.CandleMessage.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CandleMessage::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dydxprotocol.indexer.socks.CandleMessage.version)
}
inline std::string* CandleMessage::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:dydxprotocol.indexer.socks.CandleMessage.version)
  return _s;
}
inline const std::string& CandleMessage::_internal_version() const {
  return _impl_.version_.Get();
}
inline void CandleMessage::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* CandleMessage::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* CandleMessage::release_version() {
  // @@protoc_insertion_point(field_release:dydxprotocol.indexer.socks.CandleMessage.version)
  return _impl_.version_.Release();
}
inline void CandleMessage::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.socks.CandleMessage.version)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace socks
}  // namespace indexer
}  // namespace dydxprotocol


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::dydxprotocol::indexer::socks::CandleMessage_Resolution> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::dydxprotocol::indexer::socks::CandleMessage_Resolution>() {
  return ::dydxprotocol::indexer::socks::CandleMessage_Resolution_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_dydxprotocol_2findexer_2fsocks_2fmessages_2eproto_2epb_2eh
