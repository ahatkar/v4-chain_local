// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dydxprotocol/indexer/events/events.proto

#include "dydxprotocol/indexer/events/events.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace dydxprotocol {
namespace indexer {
namespace events {
template <typename>
PROTOBUF_CONSTEXPR FundingUpdateV1::FundingUpdateV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.funding_index_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.perpetual_id_)*/ 0u

  , /*decltype(_impl_.funding_value_ppm_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FundingUpdateV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR FundingUpdateV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FundingUpdateV1DefaultTypeInternal() {}
  union {
    FundingUpdateV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FundingUpdateV1DefaultTypeInternal _FundingUpdateV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR FundingEventV1::FundingEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.updates_)*/{}
  , /*decltype(_impl_.type_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FundingEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR FundingEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FundingEventV1DefaultTypeInternal() {}
  union {
    FundingEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FundingEventV1DefaultTypeInternal _FundingEventV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MarketEventV1::MarketEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ 0u

  , /*decltype(_impl_.event_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct MarketEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketEventV1DefaultTypeInternal() {}
  union {
    MarketEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketEventV1DefaultTypeInternal _MarketEventV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MarketPriceUpdateEventV1::MarketPriceUpdateEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.price_with_exponent_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MarketPriceUpdateEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketPriceUpdateEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketPriceUpdateEventV1DefaultTypeInternal() {}
  union {
    MarketPriceUpdateEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketPriceUpdateEventV1DefaultTypeInternal _MarketPriceUpdateEventV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MarketBaseEventV1::MarketBaseEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pair_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.min_price_change_ppm_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MarketBaseEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketBaseEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketBaseEventV1DefaultTypeInternal() {}
  union {
    MarketBaseEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketBaseEventV1DefaultTypeInternal _MarketBaseEventV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MarketCreateEventV1::MarketCreateEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.exponent_)*/ 0
} {}
struct MarketCreateEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketCreateEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketCreateEventV1DefaultTypeInternal() {}
  union {
    MarketCreateEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketCreateEventV1DefaultTypeInternal _MarketCreateEventV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MarketModifyEventV1::MarketModifyEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_)*/nullptr} {}
struct MarketModifyEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketModifyEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketModifyEventV1DefaultTypeInternal() {}
  union {
    MarketModifyEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketModifyEventV1DefaultTypeInternal _MarketModifyEventV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SourceOfFunds::SourceOfFunds(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SourceOfFundsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SourceOfFundsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SourceOfFundsDefaultTypeInternal() {}
  union {
    SourceOfFunds _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SourceOfFundsDefaultTypeInternal _SourceOfFunds_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TransferEventV1::TransferEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sender_subaccount_id_)*/nullptr
  , /*decltype(_impl_.recipient_subaccount_id_)*/nullptr
  , /*decltype(_impl_.sender_)*/nullptr
  , /*decltype(_impl_.recipient_)*/nullptr
  , /*decltype(_impl_.amount_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.asset_id_)*/ 0u
} {}
struct TransferEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransferEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransferEventV1DefaultTypeInternal() {}
  union {
    TransferEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransferEventV1DefaultTypeInternal _TransferEventV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderFillEventV1::OrderFillEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.maker_order_)*/nullptr
  , /*decltype(_impl_.fill_amount_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.maker_fee_)*/ ::int64_t{0}

  , /*decltype(_impl_.taker_fee_)*/ ::int64_t{0}

  , /*decltype(_impl_.total_filled_maker_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.total_filled_taker_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.taker_order_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct OrderFillEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderFillEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderFillEventV1DefaultTypeInternal() {}
  union {
    OrderFillEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderFillEventV1DefaultTypeInternal _OrderFillEventV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LiquidationOrderV1::LiquidationOrderV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.liquidated_)*/nullptr
  , /*decltype(_impl_.clob_pair_id_)*/ 0u

  , /*decltype(_impl_.perpetual_id_)*/ 0u

  , /*decltype(_impl_.total_size_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.subticks_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.is_buy_)*/ false
} {}
struct LiquidationOrderV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR LiquidationOrderV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LiquidationOrderV1DefaultTypeInternal() {}
  union {
    LiquidationOrderV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LiquidationOrderV1DefaultTypeInternal _LiquidationOrderV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountUpdateEventV1::SubaccountUpdateEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.updated_perpetual_positions_)*/{}
  , /*decltype(_impl_.updated_asset_positions_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/nullptr} {}
struct SubaccountUpdateEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountUpdateEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountUpdateEventV1DefaultTypeInternal() {}
  union {
    SubaccountUpdateEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountUpdateEventV1DefaultTypeInternal _SubaccountUpdateEventV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StatefulOrderEventV1_StatefulOrderPlacementV1::StatefulOrderEventV1_StatefulOrderPlacementV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.order_)*/nullptr} {}
struct StatefulOrderEventV1_StatefulOrderPlacementV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatefulOrderEventV1_StatefulOrderPlacementV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatefulOrderEventV1_StatefulOrderPlacementV1DefaultTypeInternal() {}
  union {
    StatefulOrderEventV1_StatefulOrderPlacementV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatefulOrderEventV1_StatefulOrderPlacementV1DefaultTypeInternal _StatefulOrderEventV1_StatefulOrderPlacementV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StatefulOrderEventV1_StatefulOrderRemovalV1::StatefulOrderEventV1_StatefulOrderRemovalV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.removed_order_id_)*/nullptr
  , /*decltype(_impl_.reason_)*/ 0
} {}
struct StatefulOrderEventV1_StatefulOrderRemovalV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatefulOrderEventV1_StatefulOrderRemovalV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatefulOrderEventV1_StatefulOrderRemovalV1DefaultTypeInternal() {}
  union {
    StatefulOrderEventV1_StatefulOrderRemovalV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatefulOrderEventV1_StatefulOrderRemovalV1DefaultTypeInternal _StatefulOrderEventV1_StatefulOrderRemovalV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StatefulOrderEventV1_ConditionalOrderPlacementV1::StatefulOrderEventV1_ConditionalOrderPlacementV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.order_)*/nullptr} {}
struct StatefulOrderEventV1_ConditionalOrderPlacementV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatefulOrderEventV1_ConditionalOrderPlacementV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatefulOrderEventV1_ConditionalOrderPlacementV1DefaultTypeInternal() {}
  union {
    StatefulOrderEventV1_ConditionalOrderPlacementV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatefulOrderEventV1_ConditionalOrderPlacementV1DefaultTypeInternal _StatefulOrderEventV1_ConditionalOrderPlacementV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StatefulOrderEventV1_ConditionalOrderTriggeredV1::StatefulOrderEventV1_ConditionalOrderTriggeredV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.triggered_order_id_)*/nullptr} {}
struct StatefulOrderEventV1_ConditionalOrderTriggeredV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatefulOrderEventV1_ConditionalOrderTriggeredV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatefulOrderEventV1_ConditionalOrderTriggeredV1DefaultTypeInternal() {}
  union {
    StatefulOrderEventV1_ConditionalOrderTriggeredV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatefulOrderEventV1_ConditionalOrderTriggeredV1DefaultTypeInternal _StatefulOrderEventV1_ConditionalOrderTriggeredV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StatefulOrderEventV1_LongTermOrderPlacementV1::StatefulOrderEventV1_LongTermOrderPlacementV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.order_)*/nullptr} {}
struct StatefulOrderEventV1_LongTermOrderPlacementV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatefulOrderEventV1_LongTermOrderPlacementV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatefulOrderEventV1_LongTermOrderPlacementV1DefaultTypeInternal() {}
  union {
    StatefulOrderEventV1_LongTermOrderPlacementV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatefulOrderEventV1_LongTermOrderPlacementV1DefaultTypeInternal _StatefulOrderEventV1_LongTermOrderPlacementV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StatefulOrderEventV1::StatefulOrderEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.event_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct StatefulOrderEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatefulOrderEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatefulOrderEventV1DefaultTypeInternal() {}
  union {
    StatefulOrderEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatefulOrderEventV1DefaultTypeInternal _StatefulOrderEventV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AssetCreateEventV1::AssetCreateEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.symbol_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.id_)*/ 0u

  , /*decltype(_impl_.has_market_)*/ false

  , /*decltype(_impl_.market_id_)*/ 0u

  , /*decltype(_impl_.atomic_resolution_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AssetCreateEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR AssetCreateEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AssetCreateEventV1DefaultTypeInternal() {}
  union {
    AssetCreateEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AssetCreateEventV1DefaultTypeInternal _AssetCreateEventV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PerpetualMarketCreateEventV1::PerpetualMarketCreateEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ticker_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.id_)*/ 0u

  , /*decltype(_impl_.clob_pair_id_)*/ 0u

  , /*decltype(_impl_.market_id_)*/ 0u

  , /*decltype(_impl_.status_)*/ 0

  , /*decltype(_impl_.quantum_conversion_exponent_)*/ 0

  , /*decltype(_impl_.atomic_resolution_)*/ 0

  , /*decltype(_impl_.step_base_quantums_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.subticks_per_tick_)*/ 0u

  , /*decltype(_impl_.liquidity_tier_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PerpetualMarketCreateEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR PerpetualMarketCreateEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PerpetualMarketCreateEventV1DefaultTypeInternal() {}
  union {
    PerpetualMarketCreateEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PerpetualMarketCreateEventV1DefaultTypeInternal _PerpetualMarketCreateEventV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LiquidityTierUpsertEventV1::LiquidityTierUpsertEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.id_)*/ 0u

  , /*decltype(_impl_.initial_margin_ppm_)*/ 0u

  , /*decltype(_impl_.base_position_notional_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.maintenance_fraction_ppm_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LiquidityTierUpsertEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR LiquidityTierUpsertEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LiquidityTierUpsertEventV1DefaultTypeInternal() {}
  union {
    LiquidityTierUpsertEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LiquidityTierUpsertEventV1DefaultTypeInternal _LiquidityTierUpsertEventV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR UpdateClobPairEventV1::UpdateClobPairEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.clob_pair_id_)*/ 0u

  , /*decltype(_impl_.status_)*/ 0

  , /*decltype(_impl_.quantum_conversion_exponent_)*/ 0

  , /*decltype(_impl_.subticks_per_tick_)*/ 0u

  , /*decltype(_impl_.step_base_quantums_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateClobPairEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateClobPairEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateClobPairEventV1DefaultTypeInternal() {}
  union {
    UpdateClobPairEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateClobPairEventV1DefaultTypeInternal _UpdateClobPairEventV1_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR UpdatePerpetualEventV1::UpdatePerpetualEventV1(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ticker_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.id_)*/ 0u

  , /*decltype(_impl_.market_id_)*/ 0u

  , /*decltype(_impl_.atomic_resolution_)*/ 0

  , /*decltype(_impl_.liquidity_tier_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdatePerpetualEventV1DefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdatePerpetualEventV1DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdatePerpetualEventV1DefaultTypeInternal() {}
  union {
    UpdatePerpetualEventV1 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdatePerpetualEventV1DefaultTypeInternal _UpdatePerpetualEventV1_default_instance_;
}  // namespace events
}  // namespace indexer
}  // namespace dydxprotocol
static ::_pb::Metadata file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[23];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_dydxprotocol_2findexer_2fevents_2fevents_2eproto[1];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_dydxprotocol_2findexer_2fevents_2fevents_2eproto = nullptr;
const ::uint32_t TableStruct_dydxprotocol_2findexer_2fevents_2fevents_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::FundingUpdateV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::FundingUpdateV1, _impl_.perpetual_id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::FundingUpdateV1, _impl_.funding_value_ppm_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::FundingUpdateV1, _impl_.funding_index_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::FundingEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::FundingEventV1, _impl_.updates_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::FundingEventV1, _impl_.type_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketEventV1, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketEventV1, _impl_.market_id_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketEventV1, _impl_.event_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketPriceUpdateEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketPriceUpdateEventV1, _impl_.price_with_exponent_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketBaseEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketBaseEventV1, _impl_.pair_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketBaseEventV1, _impl_.min_price_change_ppm_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketCreateEventV1, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketCreateEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketCreateEventV1, _impl_.base_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketCreateEventV1, _impl_.exponent_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketModifyEventV1, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketModifyEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketModifyEventV1, _impl_.base_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::SourceOfFunds, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::SourceOfFunds, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::SourceOfFunds, _impl_.source_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::TransferEventV1, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::TransferEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::TransferEventV1, _impl_.sender_subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::TransferEventV1, _impl_.recipient_subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::TransferEventV1, _impl_.asset_id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::TransferEventV1, _impl_.amount_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::TransferEventV1, _impl_.sender_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::TransferEventV1, _impl_.recipient_),
    0,
    1,
    ~0u,
    ~0u,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::OrderFillEventV1, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::OrderFillEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::OrderFillEventV1, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::OrderFillEventV1, _impl_.maker_order_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::OrderFillEventV1, _impl_.fill_amount_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::OrderFillEventV1, _impl_.maker_fee_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::OrderFillEventV1, _impl_.taker_fee_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::OrderFillEventV1, _impl_.total_filled_maker_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::OrderFillEventV1, _impl_.total_filled_taker_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::OrderFillEventV1, _impl_.taker_order_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::LiquidationOrderV1, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::LiquidationOrderV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::LiquidationOrderV1, _impl_.liquidated_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::LiquidationOrderV1, _impl_.clob_pair_id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::LiquidationOrderV1, _impl_.perpetual_id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::LiquidationOrderV1, _impl_.total_size_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::LiquidationOrderV1, _impl_.is_buy_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::LiquidationOrderV1, _impl_.subticks_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::SubaccountUpdateEventV1, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::SubaccountUpdateEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::SubaccountUpdateEventV1, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::SubaccountUpdateEventV1, _impl_.updated_perpetual_positions_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::SubaccountUpdateEventV1, _impl_.updated_asset_positions_),
    0,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderPlacementV1, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderPlacementV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderPlacementV1, _impl_.order_),
    0,
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderRemovalV1, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderRemovalV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderRemovalV1, _impl_.removed_order_id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderRemovalV1, _impl_.reason_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderPlacementV1, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderPlacementV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderPlacementV1, _impl_.order_),
    0,
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderTriggeredV1, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderTriggeredV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderTriggeredV1, _impl_.triggered_order_id_),
    0,
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_LongTermOrderPlacementV1, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_LongTermOrderPlacementV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1_LongTermOrderPlacementV1, _impl_.order_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1, _impl_.event_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::AssetCreateEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::AssetCreateEventV1, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::AssetCreateEventV1, _impl_.symbol_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::AssetCreateEventV1, _impl_.has_market_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::AssetCreateEventV1, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::AssetCreateEventV1, _impl_.atomic_resolution_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1, _impl_.clob_pair_id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1, _impl_.ticker_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1, _impl_.status_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1, _impl_.quantum_conversion_exponent_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1, _impl_.atomic_resolution_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1, _impl_.subticks_per_tick_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1, _impl_.step_base_quantums_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1, _impl_.liquidity_tier_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::LiquidityTierUpsertEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::LiquidityTierUpsertEventV1, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::LiquidityTierUpsertEventV1, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::LiquidityTierUpsertEventV1, _impl_.initial_margin_ppm_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::LiquidityTierUpsertEventV1, _impl_.maintenance_fraction_ppm_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::LiquidityTierUpsertEventV1, _impl_.base_position_notional_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::UpdateClobPairEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::UpdateClobPairEventV1, _impl_.clob_pair_id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::UpdateClobPairEventV1, _impl_.status_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::UpdateClobPairEventV1, _impl_.quantum_conversion_exponent_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::UpdateClobPairEventV1, _impl_.subticks_per_tick_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::UpdateClobPairEventV1, _impl_.step_base_quantums_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::UpdatePerpetualEventV1, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::UpdatePerpetualEventV1, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::UpdatePerpetualEventV1, _impl_.ticker_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::UpdatePerpetualEventV1, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::UpdatePerpetualEventV1, _impl_.atomic_resolution_),
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::UpdatePerpetualEventV1, _impl_.liquidity_tier_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::dydxprotocol::indexer::events::FundingUpdateV1)},
        { 11, -1, -1, sizeof(::dydxprotocol::indexer::events::FundingEventV1)},
        { 21, -1, -1, sizeof(::dydxprotocol::indexer::events::MarketEventV1)},
        { 34, -1, -1, sizeof(::dydxprotocol::indexer::events::MarketPriceUpdateEventV1)},
        { 43, -1, -1, sizeof(::dydxprotocol::indexer::events::MarketBaseEventV1)},
        { 53, 63, -1, sizeof(::dydxprotocol::indexer::events::MarketCreateEventV1)},
        { 65, 74, -1, sizeof(::dydxprotocol::indexer::events::MarketModifyEventV1)},
        { 75, -1, -1, sizeof(::dydxprotocol::indexer::events::SourceOfFunds)},
        { 86, 100, -1, sizeof(::dydxprotocol::indexer::events::TransferEventV1)},
        { 106, 123, -1, sizeof(::dydxprotocol::indexer::events::OrderFillEventV1)},
        { 131, 145, -1, sizeof(::dydxprotocol::indexer::events::LiquidationOrderV1)},
        { 151, 162, -1, sizeof(::dydxprotocol::indexer::events::SubaccountUpdateEventV1)},
        { 165, 174, -1, sizeof(::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderPlacementV1)},
        { 175, 185, -1, sizeof(::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderRemovalV1)},
        { 187, 196, -1, sizeof(::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderPlacementV1)},
        { 197, 206, -1, sizeof(::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderTriggeredV1)},
        { 207, 216, -1, sizeof(::dydxprotocol::indexer::events::StatefulOrderEventV1_LongTermOrderPlacementV1)},
        { 217, -1, -1, sizeof(::dydxprotocol::indexer::events::StatefulOrderEventV1)},
        { 231, -1, -1, sizeof(::dydxprotocol::indexer::events::AssetCreateEventV1)},
        { 244, -1, -1, sizeof(::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1)},
        { 262, -1, -1, sizeof(::dydxprotocol::indexer::events::LiquidityTierUpsertEventV1)},
        { 275, -1, -1, sizeof(::dydxprotocol::indexer::events::UpdateClobPairEventV1)},
        { 288, -1, -1, sizeof(::dydxprotocol::indexer::events::UpdatePerpetualEventV1)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::dydxprotocol::indexer::events::_FundingUpdateV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_FundingEventV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_MarketEventV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_MarketPriceUpdateEventV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_MarketBaseEventV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_MarketCreateEventV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_MarketModifyEventV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_SourceOfFunds_default_instance_._instance,
    &::dydxprotocol::indexer::events::_TransferEventV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_OrderFillEventV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_LiquidationOrderV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_SubaccountUpdateEventV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_StatefulOrderEventV1_StatefulOrderPlacementV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_StatefulOrderEventV1_StatefulOrderRemovalV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_StatefulOrderEventV1_ConditionalOrderPlacementV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_StatefulOrderEventV1_ConditionalOrderTriggeredV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_StatefulOrderEventV1_LongTermOrderPlacementV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_StatefulOrderEventV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_AssetCreateEventV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_PerpetualMarketCreateEventV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_LiquidityTierUpsertEventV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_UpdateClobPairEventV1_default_instance_._instance,
    &::dydxprotocol::indexer::events::_UpdatePerpetualEventV1_default_instance_._instance,
};
const char descriptor_table_protodef_dydxprotocol_2findexer_2fevents_2fevents_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n(dydxprotocol/indexer/events/events.pro"
    "to\022\033dydxprotocol.indexer.events\032\031cosmos_"
    "proto/cosmos.proto\032\024gogoproto/gogo.proto"
    "\0320dydxprotocol/indexer/shared/removal_re"
    "ason.proto\032+dydxprotocol/indexer/protoco"
    "l/v1/clob.proto\0321dydxprotocol/indexer/pr"
    "otocol/v1/subaccount.proto\"\243\001\n\017FundingUp"
    "dateV1\022\024\n\014perpetual_id\030\001 \001(\r\022\031\n\021funding_"
    "value_ppm\030\002 \001(\005\022_\n\rfunding_index\030\003 \001(\014BH"
    "\310\336\037\000\332\336\037@github.com/dydxprotocol/v4-chain"
    "/protocol/dtypes.SerializableInt\"\204\002\n\016Fun"
    "dingEventV1\022C\n\007updates\030\001 \003(\0132,.dydxproto"
    "col.indexer.events.FundingUpdateV1B\004\310\336\037\000"
    "\022>\n\004type\030\002 \001(\01620.dydxprotocol.indexer.ev"
    "ents.FundingEventV1.Type\"m\n\004Type\022\024\n\020TYPE"
    "_UNSPECIFIED\020\000\022\027\n\023TYPE_PREMIUM_SAMPLE\020\001\022"
    "\037\n\033TYPE_FUNDING_RATE_AND_INDEX\020\002\022\025\n\021TYPE"
    "_PREMIUM_VOTE\020\003\"\220\002\n\rMarketEventV1\022\021\n\tmar"
    "ket_id\030\001 \001(\r\022M\n\014price_update\030\002 \001(\01325.dyd"
    "xprotocol.indexer.events.MarketPriceUpda"
    "teEventV1H\000\022I\n\rmarket_create\030\003 \001(\01320.dyd"
    "xprotocol.indexer.events.MarketCreateEve"
    "ntV1H\000\022I\n\rmarket_modify\030\004 \001(\01320.dydxprot"
    "ocol.indexer.events.MarketModifyEventV1H"
    "\000B\007\n\005event\"7\n\030MarketPriceUpdateEventV1\022\033"
    "\n\023price_with_exponent\030\001 \001(\004\"\?\n\021MarketBas"
    "eEventV1\022\014\n\004pair\030\001 \001(\t\022\034\n\024min_price_chan"
    "ge_ppm\030\002 \001(\r\"e\n\023MarketCreateEventV1\022<\n\004b"
    "ase\030\001 \001(\0132..dydxprotocol.indexer.events."
    "MarketBaseEventV1\022\020\n\010exponent\030\002 \001(\021\"S\n\023M"
    "arketModifyEventV1\022<\n\004base\030\001 \001(\0132..dydxp"
    "rotocol.indexer.events.MarketBaseEventV1"
    "\"\226\001\n\rSourceOfFunds\022N\n\rsubaccount_id\030\001 \001("
    "\01325.dydxprotocol.indexer.protocol.v1.Ind"
    "exerSubaccountIdH\000\022+\n\007address\030\002 \001(\tB\030\322\264-"
    "\024cosmos.AddressStringH\000B\010\n\006source\"\333\002\n\017Tr"
    "ansferEventV1\022S\n\024sender_subaccount_id\030\001 "
    "\001(\01325.dydxprotocol.indexer.protocol.v1.I"
    "ndexerSubaccountId\022V\n\027recipient_subaccou"
    "nt_id\030\002 \001(\01325.dydxprotocol.indexer.proto"
    "col.v1.IndexerSubaccountId\022\020\n\010asset_id\030\003"
    " \001(\r\022\016\n\006amount\030\004 \001(\004\022:\n\006sender\030\005 \001(\0132*.d"
    "ydxprotocol.indexer.events.SourceOfFunds"
    "\022=\n\trecipient\030\006 \001(\0132*.dydxprotocol.index"
    "er.events.SourceOfFunds\"\356\002\n\020OrderFillEve"
    "ntV1\022I\n\013maker_order\030\001 \001(\0132..dydxprotocol"
    ".indexer.protocol.v1.IndexerOrderB\004\310\336\037\000\022"
    "\?\n\005order\030\002 \001(\0132..dydxprotocol.indexer.pr"
    "otocol.v1.IndexerOrderH\000\022L\n\021liquidation_"
    "order\030\004 \001(\0132/.dydxprotocol.indexer.event"
    "s.LiquidationOrderV1H\000\022\023\n\013fill_amount\030\003 "
    "\001(\004\022\021\n\tmaker_fee\030\005 \001(\022\022\021\n\ttaker_fee\030\006 \001("
    "\022\022\032\n\022total_filled_maker\030\007 \001(\004\022\032\n\022total_f"
    "illed_taker\030\010 \001(\004B\r\n\013taker_order\"\307\001\n\022Liq"
    "uidationOrderV1\022O\n\nliquidated\030\001 \001(\01325.dy"
    "dxprotocol.indexer.protocol.v1.IndexerSu"
    "baccountIdB\004\310\336\037\000\022\024\n\014clob_pair_id\030\002 \001(\r\022\024"
    "\n\014perpetual_id\030\003 \001(\r\022\022\n\ntotal_size\030\004 \001(\004"
    "\022\016\n\006is_buy\030\005 \001(\010\022\020\n\010subticks\030\006 \001(\004\"\247\002\n\027S"
    "ubaccountUpdateEventV1\022L\n\rsubaccount_id\030"
    "\001 \001(\01325.dydxprotocol.indexer.protocol.v1"
    ".IndexerSubaccountId\022_\n\033updated_perpetua"
    "l_positions\030\003 \003(\0132:.dydxprotocol.indexer"
    ".protocol.v1.IndexerPerpetualPosition\022W\n"
    "\027updated_asset_positions\030\004 \003(\01326.dydxpro"
    "tocol.indexer.protocol.v1.IndexerAssetPo"
    "sitionJ\004\010\002\020\003\"\367\010\n\024StatefulOrderEventV1\022a\n"
    "\013order_place\030\001 \001(\0132J.dydxprotocol.indexe"
    "r.events.StatefulOrderEventV1.StatefulOr"
    "derPlacementV1H\000\022a\n\rorder_removal\030\004 \001(\0132"
    "H.dydxprotocol.indexer.events.StatefulOr"
    "derEventV1.StatefulOrderRemovalV1H\000\022t\n\033c"
    "onditional_order_placement\030\005 \001(\0132M.dydxp"
    "rotocol.indexer.events.StatefulOrderEven"
    "tV1.ConditionalOrderPlacementV1H\000\022t\n\033con"
    "ditional_order_triggered\030\006 \001(\0132M.dydxpro"
    "tocol.indexer.events.StatefulOrderEventV"
    "1.ConditionalOrderTriggeredV1H\000\022o\n\031long_"
    "term_order_placement\030\007 \001(\0132J.dydxprotoco"
    "l.indexer.events.StatefulOrderEventV1.Lo"
    "ngTermOrderPlacementV1H\000\032Y\n\030StatefulOrde"
    "rPlacementV1\022=\n\005order\030\001 \001(\0132..dydxprotoc"
    "ol.indexer.protocol.v1.IndexerOrder\032\245\001\n\026"
    "StatefulOrderRemovalV1\022J\n\020removed_order_"
    "id\030\001 \001(\01320.dydxprotocol.indexer.protocol"
    ".v1.IndexerOrderId\022\?\n\006reason\030\002 \001(\0162/.dyd"
    "xprotocol.indexer.shared.OrderRemovalRea"
    "son\032\\\n\033ConditionalOrderPlacementV1\022=\n\005or"
    "der\030\001 \001(\0132..dydxprotocol.indexer.protoco"
    "l.v1.IndexerOrder\032k\n\033ConditionalOrderTri"
    "ggeredV1\022L\n\022triggered_order_id\030\001 \001(\01320.d"
    "ydxprotocol.indexer.protocol.v1.IndexerO"
    "rderId\032Y\n\030LongTermOrderPlacementV1\022=\n\005or"
    "der\030\001 \001(\0132..dydxprotocol.indexer.protoco"
    "l.v1.IndexerOrderB\007\n\005eventJ\004\010\002\020\003J\004\010\003\020\004\"r"
    "\n\022AssetCreateEventV1\022\n\n\002id\030\001 \001(\r\022\016\n\006symb"
    "ol\030\002 \001(\t\022\022\n\nhas_market\030\003 \001(\010\022\021\n\tmarket_i"
    "d\030\004 \001(\r\022\031\n\021atomic_resolution\030\005 \001(\021\"\264\002\n\034P"
    "erpetualMarketCreateEventV1\022\n\n\002id\030\001 \001(\r\022"
    "\024\n\014clob_pair_id\030\002 \001(\r\022\016\n\006ticker\030\003 \001(\t\022\021\n"
    "\tmarket_id\030\004 \001(\r\022@\n\006status\030\005 \001(\01620.dydxp"
    "rotocol.indexer.protocol.v1.ClobPairStat"
    "us\022#\n\033quantum_conversion_exponent\030\006 \001(\021\022"
    "\031\n\021atomic_resolution\030\007 \001(\021\022\031\n\021subticks_p"
    "er_tick\030\010 \001(\r\022\032\n\022step_base_quantums\030\t \001("
    "\004\022\026\n\016liquidity_tier\030\n \001(\r\"\224\001\n\032LiquidityT"
    "ierUpsertEventV1\022\n\n\002id\030\001 \001(\r\022\014\n\004name\030\002 \001"
    "(\t\022\032\n\022initial_margin_ppm\030\003 \001(\r\022 \n\030mainte"
    "nance_fraction_ppm\030\004 \001(\r\022\036\n\026base_positio"
    "n_notional\030\005 \001(\004\"\313\001\n\025UpdateClobPairEvent"
    "V1\022\024\n\014clob_pair_id\030\001 \001(\r\022@\n\006status\030\002 \001(\016"
    "20.dydxprotocol.indexer.protocol.v1.Clob"
    "PairStatus\022#\n\033quantum_conversion_exponen"
    "t\030\003 \001(\021\022\031\n\021subticks_per_tick\030\004 \001(\r\022\032\n\022st"
    "ep_base_quantums\030\005 \001(\004\"z\n\026UpdatePerpetua"
    "lEventV1\022\n\n\002id\030\001 \001(\r\022\016\n\006ticker\030\002 \001(\t\022\021\n\t"
    "market_id\030\003 \001(\r\022\031\n\021atomic_resolution\030\004 \001"
    "(\021\022\026\n\016liquidity_tier\030\005 \001(\rB:Z8github.com"
    "/dydxprotocol/v4-chain/protocol/indexer/"
    "eventsb\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_deps[5] =
    {
        &::descriptor_table_cosmos_5fproto_2fcosmos_2eproto,
        &::descriptor_table_dydxprotocol_2findexer_2fprotocol_2fv1_2fclob_2eproto,
        &::descriptor_table_dydxprotocol_2findexer_2fprotocol_2fv1_2fsubaccount_2eproto,
        &::descriptor_table_dydxprotocol_2findexer_2fshared_2fremoval_5freason_2eproto,
        &::descriptor_table_gogoproto_2fgogo_2eproto,
};
static ::absl::once_flag descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto = {
    false,
    false,
    4774,
    descriptor_table_protodef_dydxprotocol_2findexer_2fevents_2fevents_2eproto,
    "dydxprotocol/indexer/events/events.proto",
    &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
    descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_deps,
    5,
    23,
    schemas,
    file_default_instances,
    TableStruct_dydxprotocol_2findexer_2fevents_2fevents_2eproto::offsets,
    file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto,
    file_level_enum_descriptors_dydxprotocol_2findexer_2fevents_2fevents_2eproto,
    file_level_service_descriptors_dydxprotocol_2findexer_2fevents_2fevents_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter() {
  return &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_dydxprotocol_2findexer_2fevents_2fevents_2eproto(&descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto);
namespace dydxprotocol {
namespace indexer {
namespace events {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FundingEventV1_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto);
  return file_level_enum_descriptors_dydxprotocol_2findexer_2fevents_2fevents_2eproto[0];
}
bool FundingEventV1_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr FundingEventV1_Type FundingEventV1::TYPE_UNSPECIFIED;
constexpr FundingEventV1_Type FundingEventV1::TYPE_PREMIUM_SAMPLE;
constexpr FundingEventV1_Type FundingEventV1::TYPE_FUNDING_RATE_AND_INDEX;
constexpr FundingEventV1_Type FundingEventV1::TYPE_PREMIUM_VOTE;
constexpr FundingEventV1_Type FundingEventV1::Type_MIN;
constexpr FundingEventV1_Type FundingEventV1::Type_MAX;
constexpr int FundingEventV1::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class FundingUpdateV1::_Internal {
 public:
};

FundingUpdateV1::FundingUpdateV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.FundingUpdateV1)
}
FundingUpdateV1::FundingUpdateV1(const FundingUpdateV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FundingUpdateV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.funding_index_) {}

    , decltype(_impl_.perpetual_id_) {}

    , decltype(_impl_.funding_value_ppm_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.funding_index_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.funding_index_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_funding_index().empty()) {
    _this->_impl_.funding_index_.Set(from._internal_funding_index(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.perpetual_id_, &from._impl_.perpetual_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.funding_value_ppm_) -
    reinterpret_cast<char*>(&_impl_.perpetual_id_)) + sizeof(_impl_.funding_value_ppm_));
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.FundingUpdateV1)
}

inline void FundingUpdateV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.funding_index_) {}

    , decltype(_impl_.perpetual_id_) { 0u }

    , decltype(_impl_.funding_value_ppm_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.funding_index_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.funding_index_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FundingUpdateV1::~FundingUpdateV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.FundingUpdateV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FundingUpdateV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.funding_index_.Destroy();
}

void FundingUpdateV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FundingUpdateV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.FundingUpdateV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.funding_index_.ClearToEmpty();
  ::memset(&_impl_.perpetual_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.funding_value_ppm_) -
      reinterpret_cast<char*>(&_impl_.perpetual_id_)) + sizeof(_impl_.funding_value_ppm_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FundingUpdateV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 perpetual_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.perpetual_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 funding_value_ppm = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.funding_value_ppm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes funding_index = 3 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/dydxprotocol/v4-chain/protocol/dtypes.SerializableInt"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_funding_index();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FundingUpdateV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.FundingUpdateV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 perpetual_id = 1;
  if (this->_internal_perpetual_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_perpetual_id(), target);
  }

  // int32 funding_value_ppm = 2;
  if (this->_internal_funding_value_ppm() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_funding_value_ppm(), target);
  }

  // bytes funding_index = 3 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/dydxprotocol/v4-chain/protocol/dtypes.SerializableInt"];
  if (!this->_internal_funding_index().empty()) {
    const std::string& _s = this->_internal_funding_index();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.FundingUpdateV1)
  return target;
}

::size_t FundingUpdateV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.FundingUpdateV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes funding_index = 3 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/dydxprotocol/v4-chain/protocol/dtypes.SerializableInt"];
  if (!this->_internal_funding_index().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_funding_index());
  }

  // uint32 perpetual_id = 1;
  if (this->_internal_perpetual_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_perpetual_id());
  }

  // int32 funding_value_ppm = 2;
  if (this->_internal_funding_value_ppm() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_funding_value_ppm());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FundingUpdateV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FundingUpdateV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FundingUpdateV1::GetClassData() const { return &_class_data_; }


void FundingUpdateV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FundingUpdateV1*>(&to_msg);
  auto& from = static_cast<const FundingUpdateV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.FundingUpdateV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_funding_index().empty()) {
    _this->_internal_set_funding_index(from._internal_funding_index());
  }
  if (from._internal_perpetual_id() != 0) {
    _this->_internal_set_perpetual_id(from._internal_perpetual_id());
  }
  if (from._internal_funding_value_ppm() != 0) {
    _this->_internal_set_funding_value_ppm(from._internal_funding_value_ppm());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FundingUpdateV1::CopyFrom(const FundingUpdateV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.FundingUpdateV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FundingUpdateV1::IsInitialized() const {
  return true;
}

void FundingUpdateV1::InternalSwap(FundingUpdateV1* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.funding_index_, lhs_arena,
                                       &other->_impl_.funding_index_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FundingUpdateV1, _impl_.funding_value_ppm_)
      + sizeof(FundingUpdateV1::_impl_.funding_value_ppm_)
      - PROTOBUF_FIELD_OFFSET(FundingUpdateV1, _impl_.perpetual_id_)>(
          reinterpret_cast<char*>(&_impl_.perpetual_id_),
          reinterpret_cast<char*>(&other->_impl_.perpetual_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FundingUpdateV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[0]);
}
// ===================================================================

class FundingEventV1::_Internal {
 public:
};

FundingEventV1::FundingEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.FundingEventV1)
}
FundingEventV1::FundingEventV1(const FundingEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FundingEventV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.updates_){from._impl_.updates_}
    , decltype(_impl_.type_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.FundingEventV1)
}

inline void FundingEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.updates_){arena}
    , decltype(_impl_.type_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FundingEventV1::~FundingEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.FundingEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FundingEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_updates()->~RepeatedPtrField();
}

void FundingEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FundingEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.FundingEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_updates()->Clear();
  _impl_.type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FundingEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .dydxprotocol.indexer.events.FundingUpdateV1 updates = 1 [(.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_updates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.events.FundingEventV1.Type type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::dydxprotocol::indexer::events::FundingEventV1_Type>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FundingEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.FundingEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .dydxprotocol.indexer.events.FundingUpdateV1 updates = 1 [(.gogoproto.nullable) = false];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_updates_size()); i < n; i++) {
    const auto& repfield = this->_internal_updates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .dydxprotocol.indexer.events.FundingEventV1.Type type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.FundingEventV1)
  return target;
}

::size_t FundingEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.FundingEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .dydxprotocol.indexer.events.FundingUpdateV1 updates = 1 [(.gogoproto.nullable) = false];
  total_size += 1UL * this->_internal_updates_size();
  for (const auto& msg : this->_internal_updates()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .dydxprotocol.indexer.events.FundingEventV1.Type type = 2;
  if (this->_internal_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FundingEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FundingEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FundingEventV1::GetClassData() const { return &_class_data_; }


void FundingEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FundingEventV1*>(&to_msg);
  auto& from = static_cast<const FundingEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.FundingEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_updates()->MergeFrom(from._internal_updates());
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FundingEventV1::CopyFrom(const FundingEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.FundingEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FundingEventV1::IsInitialized() const {
  return true;
}

void FundingEventV1::InternalSwap(FundingEventV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_updates()->InternalSwap(other->_internal_mutable_updates());
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FundingEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[1]);
}
// ===================================================================

class MarketEventV1::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::MarketEventV1, _impl_._oneof_case_);
  static const ::dydxprotocol::indexer::events::MarketPriceUpdateEventV1& price_update(const MarketEventV1* msg);
  static const ::dydxprotocol::indexer::events::MarketCreateEventV1& market_create(const MarketEventV1* msg);
  static const ::dydxprotocol::indexer::events::MarketModifyEventV1& market_modify(const MarketEventV1* msg);
};

const ::dydxprotocol::indexer::events::MarketPriceUpdateEventV1&
MarketEventV1::_Internal::price_update(const MarketEventV1* msg) {
  return *msg->_impl_.event_.price_update_;
}
const ::dydxprotocol::indexer::events::MarketCreateEventV1&
MarketEventV1::_Internal::market_create(const MarketEventV1* msg) {
  return *msg->_impl_.event_.market_create_;
}
const ::dydxprotocol::indexer::events::MarketModifyEventV1&
MarketEventV1::_Internal::market_modify(const MarketEventV1* msg) {
  return *msg->_impl_.event_.market_modify_;
}
void MarketEventV1::set_allocated_price_update(::dydxprotocol::indexer::events::MarketPriceUpdateEventV1* price_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_event();
  if (price_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(price_update);
    if (message_arena != submessage_arena) {
      price_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, price_update, submessage_arena);
    }
    set_has_price_update();
    _impl_.event_.price_update_ = price_update;
  }
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.events.MarketEventV1.price_update)
}
void MarketEventV1::set_allocated_market_create(::dydxprotocol::indexer::events::MarketCreateEventV1* market_create) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_event();
  if (market_create) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(market_create);
    if (message_arena != submessage_arena) {
      market_create = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market_create, submessage_arena);
    }
    set_has_market_create();
    _impl_.event_.market_create_ = market_create;
  }
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.events.MarketEventV1.market_create)
}
void MarketEventV1::set_allocated_market_modify(::dydxprotocol::indexer::events::MarketModifyEventV1* market_modify) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_event();
  if (market_modify) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(market_modify);
    if (message_arena != submessage_arena) {
      market_modify = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market_modify, submessage_arena);
    }
    set_has_market_modify();
    _impl_.event_.market_modify_ = market_modify;
  }
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.events.MarketEventV1.market_modify)
}
MarketEventV1::MarketEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.MarketEventV1)
}
MarketEventV1::MarketEventV1(const MarketEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MarketEventV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.event_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.market_id_ = from._impl_.market_id_;
  clear_has_event();
  switch (from.event_case()) {
    case kPriceUpdate: {
      _this->_internal_mutable_price_update()->::dydxprotocol::indexer::events::MarketPriceUpdateEventV1::MergeFrom(
          from._internal_price_update());
      break;
    }
    case kMarketCreate: {
      _this->_internal_mutable_market_create()->::dydxprotocol::indexer::events::MarketCreateEventV1::MergeFrom(
          from._internal_market_create());
      break;
    }
    case kMarketModify: {
      _this->_internal_mutable_market_modify()->::dydxprotocol::indexer::events::MarketModifyEventV1::MergeFrom(
          from._internal_market_modify());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.MarketEventV1)
}

inline void MarketEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) { 0u }

    , decltype(_impl_.event_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_event();
}

MarketEventV1::~MarketEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.MarketEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_event()) {
    clear_event();
  }
}

void MarketEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketEventV1::clear_event() {
// @@protoc_insertion_point(one_of_clear_start:dydxprotocol.indexer.events.MarketEventV1)
  switch (event_case()) {
    case kPriceUpdate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.event_.price_update_;
      }
      break;
    }
    case kMarketCreate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.event_.market_create_;
      }
      break;
    }
    case kMarketModify: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.event_.market_modify_;
      }
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}


void MarketEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.MarketEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_ = 0u;
  clear_event();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 market_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.market_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.events.MarketPriceUpdateEventV1 price_update = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_price_update(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.events.MarketCreateEventV1 market_create = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_market_create(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.events.MarketModifyEventV1 market_modify = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_market_modify(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MarketEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.MarketEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 market_id = 1;
  if (this->_internal_market_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_market_id(), target);
  }

  switch (event_case()) {
    case kPriceUpdate: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::price_update(this),
          _Internal::price_update(this).GetCachedSize(), target, stream);
      break;
    }
    case kMarketCreate: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::market_create(this),
          _Internal::market_create(this).GetCachedSize(), target, stream);
      break;
    }
    case kMarketModify: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::market_modify(this),
          _Internal::market_modify(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.MarketEventV1)
  return target;
}

::size_t MarketEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.MarketEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 market_id = 1;
  if (this->_internal_market_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_market_id());
  }

  switch (event_case()) {
    // .dydxprotocol.indexer.events.MarketPriceUpdateEventV1 price_update = 2;
    case kPriceUpdate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.event_.price_update_);
      break;
    }
    // .dydxprotocol.indexer.events.MarketCreateEventV1 market_create = 3;
    case kMarketCreate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.event_.market_create_);
      break;
    }
    // .dydxprotocol.indexer.events.MarketModifyEventV1 market_modify = 4;
    case kMarketModify: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.event_.market_modify_);
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketEventV1::GetClassData() const { return &_class_data_; }


void MarketEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketEventV1*>(&to_msg);
  auto& from = static_cast<const MarketEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.MarketEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_market_id() != 0) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  switch (from.event_case()) {
    case kPriceUpdate: {
      _this->_internal_mutable_price_update()->::dydxprotocol::indexer::events::MarketPriceUpdateEventV1::MergeFrom(
          from._internal_price_update());
      break;
    }
    case kMarketCreate: {
      _this->_internal_mutable_market_create()->::dydxprotocol::indexer::events::MarketCreateEventV1::MergeFrom(
          from._internal_market_create());
      break;
    }
    case kMarketModify: {
      _this->_internal_mutable_market_modify()->::dydxprotocol::indexer::events::MarketModifyEventV1::MergeFrom(
          from._internal_market_modify());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketEventV1::CopyFrom(const MarketEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.MarketEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketEventV1::IsInitialized() const {
  return true;
}

void MarketEventV1::InternalSwap(MarketEventV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.market_id_, other->_impl_.market_id_);
  swap(_impl_.event_, other->_impl_.event_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[2]);
}
// ===================================================================

class MarketPriceUpdateEventV1::_Internal {
 public:
};

MarketPriceUpdateEventV1::MarketPriceUpdateEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.MarketPriceUpdateEventV1)
}
MarketPriceUpdateEventV1::MarketPriceUpdateEventV1(const MarketPriceUpdateEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.MarketPriceUpdateEventV1)
}

inline void MarketPriceUpdateEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.price_with_exponent_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MarketPriceUpdateEventV1::~MarketPriceUpdateEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.MarketPriceUpdateEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketPriceUpdateEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void MarketPriceUpdateEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketPriceUpdateEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.MarketPriceUpdateEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.price_with_exponent_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketPriceUpdateEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 price_with_exponent = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.price_with_exponent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MarketPriceUpdateEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.MarketPriceUpdateEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 price_with_exponent = 1;
  if (this->_internal_price_with_exponent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_price_with_exponent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.MarketPriceUpdateEventV1)
  return target;
}

::size_t MarketPriceUpdateEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.MarketPriceUpdateEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 price_with_exponent = 1;
  if (this->_internal_price_with_exponent() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_price_with_exponent());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketPriceUpdateEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketPriceUpdateEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketPriceUpdateEventV1::GetClassData() const { return &_class_data_; }


void MarketPriceUpdateEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketPriceUpdateEventV1*>(&to_msg);
  auto& from = static_cast<const MarketPriceUpdateEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.MarketPriceUpdateEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_price_with_exponent() != 0) {
    _this->_internal_set_price_with_exponent(from._internal_price_with_exponent());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketPriceUpdateEventV1::CopyFrom(const MarketPriceUpdateEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.MarketPriceUpdateEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketPriceUpdateEventV1::IsInitialized() const {
  return true;
}

void MarketPriceUpdateEventV1::InternalSwap(MarketPriceUpdateEventV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.price_with_exponent_, other->_impl_.price_with_exponent_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketPriceUpdateEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[3]);
}
// ===================================================================

class MarketBaseEventV1::_Internal {
 public:
};

MarketBaseEventV1::MarketBaseEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.MarketBaseEventV1)
}
MarketBaseEventV1::MarketBaseEventV1(const MarketBaseEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MarketBaseEventV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pair_) {}

    , decltype(_impl_.min_price_change_ppm_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pair_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.pair_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pair().empty()) {
    _this->_impl_.pair_.Set(from._internal_pair(), _this->GetArenaForAllocation());
  }
  _this->_impl_.min_price_change_ppm_ = from._impl_.min_price_change_ppm_;
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.MarketBaseEventV1)
}

inline void MarketBaseEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.pair_) {}

    , decltype(_impl_.min_price_change_ppm_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.pair_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.pair_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MarketBaseEventV1::~MarketBaseEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.MarketBaseEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketBaseEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pair_.Destroy();
}

void MarketBaseEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketBaseEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.MarketBaseEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pair_.ClearToEmpty();
  _impl_.min_price_change_ppm_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketBaseEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string pair = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pair();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "dydxprotocol.indexer.events.MarketBaseEventV1.pair"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 min_price_change_ppm = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.min_price_change_ppm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MarketBaseEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.MarketBaseEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string pair = 1;
  if (!this->_internal_pair().empty()) {
    const std::string& _s = this->_internal_pair();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "dydxprotocol.indexer.events.MarketBaseEventV1.pair");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // uint32 min_price_change_ppm = 2;
  if (this->_internal_min_price_change_ppm() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_min_price_change_ppm(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.MarketBaseEventV1)
  return target;
}

::size_t MarketBaseEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.MarketBaseEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string pair = 1;
  if (!this->_internal_pair().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_pair());
  }

  // uint32 min_price_change_ppm = 2;
  if (this->_internal_min_price_change_ppm() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_min_price_change_ppm());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketBaseEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketBaseEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketBaseEventV1::GetClassData() const { return &_class_data_; }


void MarketBaseEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketBaseEventV1*>(&to_msg);
  auto& from = static_cast<const MarketBaseEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.MarketBaseEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_pair().empty()) {
    _this->_internal_set_pair(from._internal_pair());
  }
  if (from._internal_min_price_change_ppm() != 0) {
    _this->_internal_set_min_price_change_ppm(from._internal_min_price_change_ppm());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketBaseEventV1::CopyFrom(const MarketBaseEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.MarketBaseEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketBaseEventV1::IsInitialized() const {
  return true;
}

void MarketBaseEventV1::InternalSwap(MarketBaseEventV1* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.pair_, lhs_arena,
                                       &other->_impl_.pair_, rhs_arena);

  swap(_impl_.min_price_change_ppm_, other->_impl_.min_price_change_ppm_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketBaseEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[4]);
}
// ===================================================================

class MarketCreateEventV1::_Internal {
 public:
  using HasBits = decltype(std::declval<MarketCreateEventV1>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MarketCreateEventV1, _impl_._has_bits_);
  static const ::dydxprotocol::indexer::events::MarketBaseEventV1& base(const MarketCreateEventV1* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::dydxprotocol::indexer::events::MarketBaseEventV1&
MarketCreateEventV1::_Internal::base(const MarketCreateEventV1* msg) {
  return *msg->_impl_.base_;
}
MarketCreateEventV1::MarketCreateEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.MarketCreateEventV1)
}
MarketCreateEventV1::MarketCreateEventV1(const MarketCreateEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MarketCreateEventV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.exponent_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.base_ = new ::dydxprotocol::indexer::events::MarketBaseEventV1(*from._impl_.base_);
  }
  _this->_impl_.exponent_ = from._impl_.exponent_;
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.MarketCreateEventV1)
}

inline void MarketCreateEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.exponent_) { 0 }

  };
}

MarketCreateEventV1::~MarketCreateEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.MarketCreateEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketCreateEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
}

void MarketCreateEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketCreateEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.MarketCreateEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.base_ != nullptr);
    _impl_.base_->Clear();
  }
  _impl_.exponent_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketCreateEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dydxprotocol.indexer.events.MarketBaseEventV1 base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 exponent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.exponent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MarketCreateEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.MarketCreateEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .dydxprotocol.indexer.events.MarketBaseEventV1 base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // sint32 exponent = 2;
  if (this->_internal_exponent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        2, this->_internal_exponent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.MarketCreateEventV1)
  return target;
}

::size_t MarketCreateEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.MarketCreateEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dydxprotocol.indexer.events.MarketBaseEventV1 base = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  // sint32 exponent = 2;
  if (this->_internal_exponent() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_exponent());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketCreateEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketCreateEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketCreateEventV1::GetClassData() const { return &_class_data_; }


void MarketCreateEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketCreateEventV1*>(&to_msg);
  auto& from = static_cast<const MarketCreateEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.MarketCreateEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_base()->::dydxprotocol::indexer::events::MarketBaseEventV1::MergeFrom(
        from._internal_base());
  }
  if (from._internal_exponent() != 0) {
    _this->_internal_set_exponent(from._internal_exponent());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketCreateEventV1::CopyFrom(const MarketCreateEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.MarketCreateEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketCreateEventV1::IsInitialized() const {
  return true;
}

void MarketCreateEventV1::InternalSwap(MarketCreateEventV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MarketCreateEventV1, _impl_.exponent_)
      + sizeof(MarketCreateEventV1::_impl_.exponent_)
      - PROTOBUF_FIELD_OFFSET(MarketCreateEventV1, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketCreateEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[5]);
}
// ===================================================================

class MarketModifyEventV1::_Internal {
 public:
  using HasBits = decltype(std::declval<MarketModifyEventV1>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MarketModifyEventV1, _impl_._has_bits_);
  static const ::dydxprotocol::indexer::events::MarketBaseEventV1& base(const MarketModifyEventV1* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::dydxprotocol::indexer::events::MarketBaseEventV1&
MarketModifyEventV1::_Internal::base(const MarketModifyEventV1* msg) {
  return *msg->_impl_.base_;
}
MarketModifyEventV1::MarketModifyEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.MarketModifyEventV1)
}
MarketModifyEventV1::MarketModifyEventV1(const MarketModifyEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MarketModifyEventV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.base_ = new ::dydxprotocol::indexer::events::MarketBaseEventV1(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.MarketModifyEventV1)
}

inline void MarketModifyEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
  };
}

MarketModifyEventV1::~MarketModifyEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.MarketModifyEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketModifyEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
}

void MarketModifyEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketModifyEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.MarketModifyEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.base_ != nullptr);
    _impl_.base_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketModifyEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dydxprotocol.indexer.events.MarketBaseEventV1 base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MarketModifyEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.MarketModifyEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .dydxprotocol.indexer.events.MarketBaseEventV1 base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.MarketModifyEventV1)
  return target;
}

::size_t MarketModifyEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.MarketModifyEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dydxprotocol.indexer.events.MarketBaseEventV1 base = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketModifyEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketModifyEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketModifyEventV1::GetClassData() const { return &_class_data_; }


void MarketModifyEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketModifyEventV1*>(&to_msg);
  auto& from = static_cast<const MarketModifyEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.MarketModifyEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_base()->::dydxprotocol::indexer::events::MarketBaseEventV1::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketModifyEventV1::CopyFrom(const MarketModifyEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.MarketModifyEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketModifyEventV1::IsInitialized() const {
  return true;
}

void MarketModifyEventV1::InternalSwap(MarketModifyEventV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketModifyEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[6]);
}
// ===================================================================

class SourceOfFunds::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::SourceOfFunds, _impl_._oneof_case_);
  static const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId& subaccount_id(const SourceOfFunds* msg);
};

const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId&
SourceOfFunds::_Internal::subaccount_id(const SourceOfFunds* msg) {
  return *msg->_impl_.source_.subaccount_id_;
}
void SourceOfFunds::set_allocated_subaccount_id(::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId* subaccount_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_source();
  if (subaccount_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subaccount_id));
    if (message_arena != submessage_arena) {
      subaccount_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subaccount_id, submessage_arena);
    }
    set_has_subaccount_id();
    _impl_.source_.subaccount_id_ = subaccount_id;
  }
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.events.SourceOfFunds.subaccount_id)
}
void SourceOfFunds::clear_subaccount_id() {
  if (source_case() == kSubaccountId) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.source_.subaccount_id_;
    }
    clear_has_source();
  }
}
SourceOfFunds::SourceOfFunds(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.SourceOfFunds)
}
SourceOfFunds::SourceOfFunds(const SourceOfFunds& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SourceOfFunds* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_source();
  switch (from.source_case()) {
    case kSubaccountId: {
      _this->_internal_mutable_subaccount_id()->::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId::MergeFrom(
          from._internal_subaccount_id());
      break;
    }
    case kAddress: {
      _this->_internal_set_address(from._internal_address());
      break;
    }
    case SOURCE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.SourceOfFunds)
}

inline void SourceOfFunds::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.source_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_source();
}

SourceOfFunds::~SourceOfFunds() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.SourceOfFunds)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SourceOfFunds::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_source()) {
    clear_source();
  }
}

void SourceOfFunds::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SourceOfFunds::clear_source() {
// @@protoc_insertion_point(one_of_clear_start:dydxprotocol.indexer.events.SourceOfFunds)
  switch (source_case()) {
    case kSubaccountId: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.source_.subaccount_id_;
      }
      break;
    }
    case kAddress: {
      _impl_.source_.address_.Destroy();
      break;
    }
    case SOURCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SOURCE_NOT_SET;
}


void SourceOfFunds::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.SourceOfFunds)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_source();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SourceOfFunds::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId subaccount_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subaccount_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string address = 2 [(.cosmos_proto.scalar) = "cosmos.AddressString"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "dydxprotocol.indexer.events.SourceOfFunds.address"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SourceOfFunds::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.SourceOfFunds)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (source_case()) {
    case kSubaccountId: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::subaccount_id(this),
          _Internal::subaccount_id(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddress: {
      const std::string& _s = this->_internal_address();
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "dydxprotocol.indexer.events.SourceOfFunds.address");
      target = stream->WriteStringMaybeAliased(2, _s, target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.SourceOfFunds)
  return target;
}

::size_t SourceOfFunds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.SourceOfFunds)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (source_case()) {
    // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId subaccount_id = 1;
    case kSubaccountId: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.source_.subaccount_id_);
      break;
    }
    // string address = 2 [(.cosmos_proto.scalar) = "cosmos.AddressString"];
    case kAddress: {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_address());
      break;
    }
    case SOURCE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SourceOfFunds::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SourceOfFunds::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SourceOfFunds::GetClassData() const { return &_class_data_; }


void SourceOfFunds::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SourceOfFunds*>(&to_msg);
  auto& from = static_cast<const SourceOfFunds&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.SourceOfFunds)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.source_case()) {
    case kSubaccountId: {
      _this->_internal_mutable_subaccount_id()->::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId::MergeFrom(
          from._internal_subaccount_id());
      break;
    }
    case kAddress: {
      _this->_internal_set_address(from._internal_address());
      break;
    }
    case SOURCE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SourceOfFunds::CopyFrom(const SourceOfFunds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.SourceOfFunds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SourceOfFunds::IsInitialized() const {
  return true;
}

void SourceOfFunds::InternalSwap(SourceOfFunds* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.source_, other->_impl_.source_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SourceOfFunds::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[7]);
}
// ===================================================================

class TransferEventV1::_Internal {
 public:
  using HasBits = decltype(std::declval<TransferEventV1>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TransferEventV1, _impl_._has_bits_);
  static const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId& sender_subaccount_id(const TransferEventV1* msg);
  static void set_has_sender_subaccount_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId& recipient_subaccount_id(const TransferEventV1* msg);
  static void set_has_recipient_subaccount_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::dydxprotocol::indexer::events::SourceOfFunds& sender(const TransferEventV1* msg);
  static void set_has_sender(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::dydxprotocol::indexer::events::SourceOfFunds& recipient(const TransferEventV1* msg);
  static void set_has_recipient(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId&
TransferEventV1::_Internal::sender_subaccount_id(const TransferEventV1* msg) {
  return *msg->_impl_.sender_subaccount_id_;
}
const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId&
TransferEventV1::_Internal::recipient_subaccount_id(const TransferEventV1* msg) {
  return *msg->_impl_.recipient_subaccount_id_;
}
const ::dydxprotocol::indexer::events::SourceOfFunds&
TransferEventV1::_Internal::sender(const TransferEventV1* msg) {
  return *msg->_impl_.sender_;
}
const ::dydxprotocol::indexer::events::SourceOfFunds&
TransferEventV1::_Internal::recipient(const TransferEventV1* msg) {
  return *msg->_impl_.recipient_;
}
void TransferEventV1::clear_sender_subaccount_id() {
  if (_impl_.sender_subaccount_id_ != nullptr) _impl_.sender_subaccount_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TransferEventV1::clear_recipient_subaccount_id() {
  if (_impl_.recipient_subaccount_id_ != nullptr) _impl_.recipient_subaccount_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
TransferEventV1::TransferEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.TransferEventV1)
}
TransferEventV1::TransferEventV1(const TransferEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransferEventV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sender_subaccount_id_){nullptr}
    , decltype(_impl_.recipient_subaccount_id_){nullptr}
    , decltype(_impl_.sender_){nullptr}
    , decltype(_impl_.recipient_){nullptr}
    , decltype(_impl_.amount_) {}

    , decltype(_impl_.asset_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.sender_subaccount_id_ = new ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId(*from._impl_.sender_subaccount_id_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.recipient_subaccount_id_ = new ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId(*from._impl_.recipient_subaccount_id_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.sender_ = new ::dydxprotocol::indexer::events::SourceOfFunds(*from._impl_.sender_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.recipient_ = new ::dydxprotocol::indexer::events::SourceOfFunds(*from._impl_.recipient_);
  }
  ::memcpy(&_impl_.amount_, &from._impl_.amount_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.asset_id_) -
    reinterpret_cast<char*>(&_impl_.amount_)) + sizeof(_impl_.asset_id_));
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.TransferEventV1)
}

inline void TransferEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sender_subaccount_id_){nullptr}
    , decltype(_impl_.recipient_subaccount_id_){nullptr}
    , decltype(_impl_.sender_){nullptr}
    , decltype(_impl_.recipient_){nullptr}
    , decltype(_impl_.amount_) { ::uint64_t{0u} }

    , decltype(_impl_.asset_id_) { 0u }

  };
}

TransferEventV1::~TransferEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.TransferEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransferEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.sender_subaccount_id_;
  if (this != internal_default_instance()) delete _impl_.recipient_subaccount_id_;
  if (this != internal_default_instance()) delete _impl_.sender_;
  if (this != internal_default_instance()) delete _impl_.recipient_;
}

void TransferEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransferEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.TransferEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.sender_subaccount_id_ != nullptr);
      _impl_.sender_subaccount_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.recipient_subaccount_id_ != nullptr);
      _impl_.recipient_subaccount_id_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.sender_ != nullptr);
      _impl_.sender_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.recipient_ != nullptr);
      _impl_.recipient_->Clear();
    }
  }
  ::memset(&_impl_.amount_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.asset_id_) -
      reinterpret_cast<char*>(&_impl_.amount_)) + sizeof(_impl_.asset_id_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransferEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId sender_subaccount_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sender_subaccount_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId recipient_subaccount_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_recipient_subaccount_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 asset_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.asset_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 amount = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.events.SourceOfFunds sender = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_sender(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.events.SourceOfFunds recipient = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_recipient(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TransferEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.TransferEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId sender_subaccount_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::sender_subaccount_id(this),
        _Internal::sender_subaccount_id(this).GetCachedSize(), target, stream);
  }

  // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId recipient_subaccount_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::recipient_subaccount_id(this),
        _Internal::recipient_subaccount_id(this).GetCachedSize(), target, stream);
  }

  // uint32 asset_id = 3;
  if (this->_internal_asset_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_asset_id(), target);
  }

  // uint64 amount = 4;
  if (this->_internal_amount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_amount(), target);
  }

  // .dydxprotocol.indexer.events.SourceOfFunds sender = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::sender(this),
        _Internal::sender(this).GetCachedSize(), target, stream);
  }

  // .dydxprotocol.indexer.events.SourceOfFunds recipient = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::recipient(this),
        _Internal::recipient(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.TransferEventV1)
  return target;
}

::size_t TransferEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.TransferEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId sender_subaccount_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sender_subaccount_id_);
    }

    // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId recipient_subaccount_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.recipient_subaccount_id_);
    }

    // .dydxprotocol.indexer.events.SourceOfFunds sender = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sender_);
    }

    // .dydxprotocol.indexer.events.SourceOfFunds recipient = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.recipient_);
    }

  }
  // uint64 amount = 4;
  if (this->_internal_amount() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_amount());
  }

  // uint32 asset_id = 3;
  if (this->_internal_asset_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_asset_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransferEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransferEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransferEventV1::GetClassData() const { return &_class_data_; }


void TransferEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransferEventV1*>(&to_msg);
  auto& from = static_cast<const TransferEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.TransferEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_sender_subaccount_id()->::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId::MergeFrom(
          from._internal_sender_subaccount_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_recipient_subaccount_id()->::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId::MergeFrom(
          from._internal_recipient_subaccount_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_sender()->::dydxprotocol::indexer::events::SourceOfFunds::MergeFrom(
          from._internal_sender());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_recipient()->::dydxprotocol::indexer::events::SourceOfFunds::MergeFrom(
          from._internal_recipient());
    }
  }
  if (from._internal_amount() != 0) {
    _this->_internal_set_amount(from._internal_amount());
  }
  if (from._internal_asset_id() != 0) {
    _this->_internal_set_asset_id(from._internal_asset_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransferEventV1::CopyFrom(const TransferEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.TransferEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransferEventV1::IsInitialized() const {
  return true;
}

void TransferEventV1::InternalSwap(TransferEventV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TransferEventV1, _impl_.asset_id_)
      + sizeof(TransferEventV1::_impl_.asset_id_)
      - PROTOBUF_FIELD_OFFSET(TransferEventV1, _impl_.sender_subaccount_id_)>(
          reinterpret_cast<char*>(&_impl_.sender_subaccount_id_),
          reinterpret_cast<char*>(&other->_impl_.sender_subaccount_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TransferEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[8]);
}
// ===================================================================

class OrderFillEventV1::_Internal {
 public:
  using HasBits = decltype(std::declval<OrderFillEventV1>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(OrderFillEventV1, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::OrderFillEventV1, _impl_._oneof_case_);
  static const ::dydxprotocol::indexer::protocol::v1::IndexerOrder& maker_order(const OrderFillEventV1* msg);
  static void set_has_maker_order(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::dydxprotocol::indexer::protocol::v1::IndexerOrder& order(const OrderFillEventV1* msg);
  static const ::dydxprotocol::indexer::events::LiquidationOrderV1& liquidation_order(const OrderFillEventV1* msg);
};

const ::dydxprotocol::indexer::protocol::v1::IndexerOrder&
OrderFillEventV1::_Internal::maker_order(const OrderFillEventV1* msg) {
  return *msg->_impl_.maker_order_;
}
const ::dydxprotocol::indexer::protocol::v1::IndexerOrder&
OrderFillEventV1::_Internal::order(const OrderFillEventV1* msg) {
  return *msg->_impl_.taker_order_.order_;
}
const ::dydxprotocol::indexer::events::LiquidationOrderV1&
OrderFillEventV1::_Internal::liquidation_order(const OrderFillEventV1* msg) {
  return *msg->_impl_.taker_order_.liquidation_order_;
}
void OrderFillEventV1::clear_maker_order() {
  if (_impl_.maker_order_ != nullptr) _impl_.maker_order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void OrderFillEventV1::set_allocated_order(::dydxprotocol::indexer::protocol::v1::IndexerOrder* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_taker_order();
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order));
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    set_has_order();
    _impl_.taker_order_.order_ = order;
  }
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.events.OrderFillEventV1.order)
}
void OrderFillEventV1::clear_order() {
  if (taker_order_case() == kOrder) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.taker_order_.order_;
    }
    clear_has_taker_order();
  }
}
void OrderFillEventV1::set_allocated_liquidation_order(::dydxprotocol::indexer::events::LiquidationOrderV1* liquidation_order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_taker_order();
  if (liquidation_order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(liquidation_order);
    if (message_arena != submessage_arena) {
      liquidation_order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, liquidation_order, submessage_arena);
    }
    set_has_liquidation_order();
    _impl_.taker_order_.liquidation_order_ = liquidation_order;
  }
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.events.OrderFillEventV1.liquidation_order)
}
OrderFillEventV1::OrderFillEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.OrderFillEventV1)
}
OrderFillEventV1::OrderFillEventV1(const OrderFillEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderFillEventV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.maker_order_){nullptr}
    , decltype(_impl_.fill_amount_) {}

    , decltype(_impl_.maker_fee_) {}

    , decltype(_impl_.taker_fee_) {}

    , decltype(_impl_.total_filled_maker_) {}

    , decltype(_impl_.total_filled_taker_) {}

    , decltype(_impl_.taker_order_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.maker_order_ = new ::dydxprotocol::indexer::protocol::v1::IndexerOrder(*from._impl_.maker_order_);
  }
  ::memcpy(&_impl_.fill_amount_, &from._impl_.fill_amount_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.total_filled_taker_) -
    reinterpret_cast<char*>(&_impl_.fill_amount_)) + sizeof(_impl_.total_filled_taker_));
  clear_has_taker_order();
  switch (from.taker_order_case()) {
    case kOrder: {
      _this->_internal_mutable_order()->::dydxprotocol::indexer::protocol::v1::IndexerOrder::MergeFrom(
          from._internal_order());
      break;
    }
    case kLiquidationOrder: {
      _this->_internal_mutable_liquidation_order()->::dydxprotocol::indexer::events::LiquidationOrderV1::MergeFrom(
          from._internal_liquidation_order());
      break;
    }
    case TAKER_ORDER_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.OrderFillEventV1)
}

inline void OrderFillEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.maker_order_){nullptr}
    , decltype(_impl_.fill_amount_) { ::uint64_t{0u} }

    , decltype(_impl_.maker_fee_) { ::int64_t{0} }

    , decltype(_impl_.taker_fee_) { ::int64_t{0} }

    , decltype(_impl_.total_filled_maker_) { ::uint64_t{0u} }

    , decltype(_impl_.total_filled_taker_) { ::uint64_t{0u} }

    , decltype(_impl_.taker_order_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_taker_order();
}

OrderFillEventV1::~OrderFillEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.OrderFillEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderFillEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.maker_order_;
  if (has_taker_order()) {
    clear_taker_order();
  }
}

void OrderFillEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderFillEventV1::clear_taker_order() {
// @@protoc_insertion_point(one_of_clear_start:dydxprotocol.indexer.events.OrderFillEventV1)
  switch (taker_order_case()) {
    case kOrder: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.taker_order_.order_;
      }
      break;
    }
    case kLiquidationOrder: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.taker_order_.liquidation_order_;
      }
      break;
    }
    case TAKER_ORDER_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TAKER_ORDER_NOT_SET;
}


void OrderFillEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.OrderFillEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.maker_order_ != nullptr);
    _impl_.maker_order_->Clear();
  }
  ::memset(&_impl_.fill_amount_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.total_filled_taker_) -
      reinterpret_cast<char*>(&_impl_.fill_amount_)) + sizeof(_impl_.total_filled_taker_));
  clear_taker_order();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderFillEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dydxprotocol.indexer.protocol.v1.IndexerOrder maker_order = 1 [(.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_maker_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.protocol.v1.IndexerOrder order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 fill_amount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.fill_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.events.LiquidationOrderV1 liquidation_order = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_liquidation_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 maker_fee = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.maker_fee_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 taker_fee = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.taker_fee_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 total_filled_maker = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.total_filled_maker_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 total_filled_taker = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.total_filled_taker_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderFillEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.OrderFillEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .dydxprotocol.indexer.protocol.v1.IndexerOrder maker_order = 1 [(.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::maker_order(this),
        _Internal::maker_order(this).GetCachedSize(), target, stream);
  }

  // .dydxprotocol.indexer.protocol.v1.IndexerOrder order = 2;
  if (taker_order_case() == kOrder) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::order(this),
        _Internal::order(this).GetCachedSize(), target, stream);
  }

  // uint64 fill_amount = 3;
  if (this->_internal_fill_amount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_fill_amount(), target);
  }

  // .dydxprotocol.indexer.events.LiquidationOrderV1 liquidation_order = 4;
  if (taker_order_case() == kLiquidationOrder) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::liquidation_order(this),
        _Internal::liquidation_order(this).GetCachedSize(), target, stream);
  }

  // sint64 maker_fee = 5;
  if (this->_internal_maker_fee() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        5, this->_internal_maker_fee(), target);
  }

  // sint64 taker_fee = 6;
  if (this->_internal_taker_fee() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        6, this->_internal_taker_fee(), target);
  }

  // uint64 total_filled_maker = 7;
  if (this->_internal_total_filled_maker() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        7, this->_internal_total_filled_maker(), target);
  }

  // uint64 total_filled_taker = 8;
  if (this->_internal_total_filled_taker() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        8, this->_internal_total_filled_taker(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.OrderFillEventV1)
  return target;
}

::size_t OrderFillEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.OrderFillEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dydxprotocol.indexer.protocol.v1.IndexerOrder maker_order = 1 [(.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.maker_order_);
  }

  // uint64 fill_amount = 3;
  if (this->_internal_fill_amount() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_fill_amount());
  }

  // sint64 maker_fee = 5;
  if (this->_internal_maker_fee() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_maker_fee());
  }

  // sint64 taker_fee = 6;
  if (this->_internal_taker_fee() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_taker_fee());
  }

  // uint64 total_filled_maker = 7;
  if (this->_internal_total_filled_maker() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_total_filled_maker());
  }

  // uint64 total_filled_taker = 8;
  if (this->_internal_total_filled_taker() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_total_filled_taker());
  }

  switch (taker_order_case()) {
    // .dydxprotocol.indexer.protocol.v1.IndexerOrder order = 2;
    case kOrder: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.taker_order_.order_);
      break;
    }
    // .dydxprotocol.indexer.events.LiquidationOrderV1 liquidation_order = 4;
    case kLiquidationOrder: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.taker_order_.liquidation_order_);
      break;
    }
    case TAKER_ORDER_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderFillEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderFillEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderFillEventV1::GetClassData() const { return &_class_data_; }


void OrderFillEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderFillEventV1*>(&to_msg);
  auto& from = static_cast<const OrderFillEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.OrderFillEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_maker_order()->::dydxprotocol::indexer::protocol::v1::IndexerOrder::MergeFrom(
        from._internal_maker_order());
  }
  if (from._internal_fill_amount() != 0) {
    _this->_internal_set_fill_amount(from._internal_fill_amount());
  }
  if (from._internal_maker_fee() != 0) {
    _this->_internal_set_maker_fee(from._internal_maker_fee());
  }
  if (from._internal_taker_fee() != 0) {
    _this->_internal_set_taker_fee(from._internal_taker_fee());
  }
  if (from._internal_total_filled_maker() != 0) {
    _this->_internal_set_total_filled_maker(from._internal_total_filled_maker());
  }
  if (from._internal_total_filled_taker() != 0) {
    _this->_internal_set_total_filled_taker(from._internal_total_filled_taker());
  }
  switch (from.taker_order_case()) {
    case kOrder: {
      _this->_internal_mutable_order()->::dydxprotocol::indexer::protocol::v1::IndexerOrder::MergeFrom(
          from._internal_order());
      break;
    }
    case kLiquidationOrder: {
      _this->_internal_mutable_liquidation_order()->::dydxprotocol::indexer::events::LiquidationOrderV1::MergeFrom(
          from._internal_liquidation_order());
      break;
    }
    case TAKER_ORDER_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderFillEventV1::CopyFrom(const OrderFillEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.OrderFillEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderFillEventV1::IsInitialized() const {
  return true;
}

void OrderFillEventV1::InternalSwap(OrderFillEventV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OrderFillEventV1, _impl_.total_filled_taker_)
      + sizeof(OrderFillEventV1::_impl_.total_filled_taker_)
      - PROTOBUF_FIELD_OFFSET(OrderFillEventV1, _impl_.maker_order_)>(
          reinterpret_cast<char*>(&_impl_.maker_order_),
          reinterpret_cast<char*>(&other->_impl_.maker_order_));
  swap(_impl_.taker_order_, other->_impl_.taker_order_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderFillEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[9]);
}
// ===================================================================

class LiquidationOrderV1::_Internal {
 public:
  using HasBits = decltype(std::declval<LiquidationOrderV1>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(LiquidationOrderV1, _impl_._has_bits_);
  static const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId& liquidated(const LiquidationOrderV1* msg);
  static void set_has_liquidated(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId&
LiquidationOrderV1::_Internal::liquidated(const LiquidationOrderV1* msg) {
  return *msg->_impl_.liquidated_;
}
void LiquidationOrderV1::clear_liquidated() {
  if (_impl_.liquidated_ != nullptr) _impl_.liquidated_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
LiquidationOrderV1::LiquidationOrderV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.LiquidationOrderV1)
}
LiquidationOrderV1::LiquidationOrderV1(const LiquidationOrderV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LiquidationOrderV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.liquidated_){nullptr}
    , decltype(_impl_.clob_pair_id_) {}

    , decltype(_impl_.perpetual_id_) {}

    , decltype(_impl_.total_size_) {}

    , decltype(_impl_.subticks_) {}

    , decltype(_impl_.is_buy_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.liquidated_ = new ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId(*from._impl_.liquidated_);
  }
  ::memcpy(&_impl_.clob_pair_id_, &from._impl_.clob_pair_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.is_buy_) -
    reinterpret_cast<char*>(&_impl_.clob_pair_id_)) + sizeof(_impl_.is_buy_));
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.LiquidationOrderV1)
}

inline void LiquidationOrderV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.liquidated_){nullptr}
    , decltype(_impl_.clob_pair_id_) { 0u }

    , decltype(_impl_.perpetual_id_) { 0u }

    , decltype(_impl_.total_size_) { ::uint64_t{0u} }

    , decltype(_impl_.subticks_) { ::uint64_t{0u} }

    , decltype(_impl_.is_buy_) { false }

  };
}

LiquidationOrderV1::~LiquidationOrderV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.LiquidationOrderV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LiquidationOrderV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.liquidated_;
}

void LiquidationOrderV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LiquidationOrderV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.LiquidationOrderV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.liquidated_ != nullptr);
    _impl_.liquidated_->Clear();
  }
  ::memset(&_impl_.clob_pair_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.is_buy_) -
      reinterpret_cast<char*>(&_impl_.clob_pair_id_)) + sizeof(_impl_.is_buy_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LiquidationOrderV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId liquidated = 1 [(.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_liquidated(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 clob_pair_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.clob_pair_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 perpetual_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.perpetual_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 total_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.total_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_buy = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.is_buy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 subticks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.subticks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LiquidationOrderV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.LiquidationOrderV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId liquidated = 1 [(.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::liquidated(this),
        _Internal::liquidated(this).GetCachedSize(), target, stream);
  }

  // uint32 clob_pair_id = 2;
  if (this->_internal_clob_pair_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_clob_pair_id(), target);
  }

  // uint32 perpetual_id = 3;
  if (this->_internal_perpetual_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_perpetual_id(), target);
  }

  // uint64 total_size = 4;
  if (this->_internal_total_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_total_size(), target);
  }

  // bool is_buy = 5;
  if (this->_internal_is_buy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_is_buy(), target);
  }

  // uint64 subticks = 6;
  if (this->_internal_subticks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_subticks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.LiquidationOrderV1)
  return target;
}

::size_t LiquidationOrderV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.LiquidationOrderV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId liquidated = 1 [(.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.liquidated_);
  }

  // uint32 clob_pair_id = 2;
  if (this->_internal_clob_pair_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_clob_pair_id());
  }

  // uint32 perpetual_id = 3;
  if (this->_internal_perpetual_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_perpetual_id());
  }

  // uint64 total_size = 4;
  if (this->_internal_total_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_total_size());
  }

  // uint64 subticks = 6;
  if (this->_internal_subticks() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_subticks());
  }

  // bool is_buy = 5;
  if (this->_internal_is_buy() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LiquidationOrderV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LiquidationOrderV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LiquidationOrderV1::GetClassData() const { return &_class_data_; }


void LiquidationOrderV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LiquidationOrderV1*>(&to_msg);
  auto& from = static_cast<const LiquidationOrderV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.LiquidationOrderV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_liquidated()->::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId::MergeFrom(
        from._internal_liquidated());
  }
  if (from._internal_clob_pair_id() != 0) {
    _this->_internal_set_clob_pair_id(from._internal_clob_pair_id());
  }
  if (from._internal_perpetual_id() != 0) {
    _this->_internal_set_perpetual_id(from._internal_perpetual_id());
  }
  if (from._internal_total_size() != 0) {
    _this->_internal_set_total_size(from._internal_total_size());
  }
  if (from._internal_subticks() != 0) {
    _this->_internal_set_subticks(from._internal_subticks());
  }
  if (from._internal_is_buy() != 0) {
    _this->_internal_set_is_buy(from._internal_is_buy());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LiquidationOrderV1::CopyFrom(const LiquidationOrderV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.LiquidationOrderV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LiquidationOrderV1::IsInitialized() const {
  return true;
}

void LiquidationOrderV1::InternalSwap(LiquidationOrderV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LiquidationOrderV1, _impl_.is_buy_)
      + sizeof(LiquidationOrderV1::_impl_.is_buy_)
      - PROTOBUF_FIELD_OFFSET(LiquidationOrderV1, _impl_.liquidated_)>(
          reinterpret_cast<char*>(&_impl_.liquidated_),
          reinterpret_cast<char*>(&other->_impl_.liquidated_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LiquidationOrderV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[10]);
}
// ===================================================================

class SubaccountUpdateEventV1::_Internal {
 public:
  using HasBits = decltype(std::declval<SubaccountUpdateEventV1>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SubaccountUpdateEventV1, _impl_._has_bits_);
  static const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId& subaccount_id(const SubaccountUpdateEventV1* msg);
  static void set_has_subaccount_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId&
SubaccountUpdateEventV1::_Internal::subaccount_id(const SubaccountUpdateEventV1* msg) {
  return *msg->_impl_.subaccount_id_;
}
void SubaccountUpdateEventV1::clear_subaccount_id() {
  if (_impl_.subaccount_id_ != nullptr) _impl_.subaccount_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void SubaccountUpdateEventV1::clear_updated_perpetual_positions() {
  _internal_mutable_updated_perpetual_positions()->Clear();
}
void SubaccountUpdateEventV1::clear_updated_asset_positions() {
  _internal_mutable_updated_asset_positions()->Clear();
}
SubaccountUpdateEventV1::SubaccountUpdateEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.SubaccountUpdateEventV1)
}
SubaccountUpdateEventV1::SubaccountUpdateEventV1(const SubaccountUpdateEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountUpdateEventV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.updated_perpetual_positions_){from._impl_.updated_perpetual_positions_}
    , decltype(_impl_.updated_asset_positions_){from._impl_.updated_asset_positions_}
    , decltype(_impl_.subaccount_id_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.subaccount_id_ = new ::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId(*from._impl_.subaccount_id_);
  }
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.SubaccountUpdateEventV1)
}

inline void SubaccountUpdateEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.updated_perpetual_positions_){arena}
    , decltype(_impl_.updated_asset_positions_){arena}
    , decltype(_impl_.subaccount_id_){nullptr}
  };
}

SubaccountUpdateEventV1::~SubaccountUpdateEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.SubaccountUpdateEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountUpdateEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_updated_perpetual_positions()->~RepeatedPtrField();
  _internal_mutable_updated_asset_positions()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.subaccount_id_;
}

void SubaccountUpdateEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountUpdateEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.SubaccountUpdateEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_updated_perpetual_positions()->Clear();
  _internal_mutable_updated_asset_positions()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.subaccount_id_ != nullptr);
    _impl_.subaccount_id_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountUpdateEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId subaccount_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subaccount_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .dydxprotocol.indexer.protocol.v1.IndexerPerpetualPosition updated_perpetual_positions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_updated_perpetual_positions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .dydxprotocol.indexer.protocol.v1.IndexerAssetPosition updated_asset_positions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_updated_asset_positions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountUpdateEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.SubaccountUpdateEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId subaccount_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::subaccount_id(this),
        _Internal::subaccount_id(this).GetCachedSize(), target, stream);
  }

  // repeated .dydxprotocol.indexer.protocol.v1.IndexerPerpetualPosition updated_perpetual_positions = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_updated_perpetual_positions_size()); i < n; i++) {
    const auto& repfield = this->_internal_updated_perpetual_positions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .dydxprotocol.indexer.protocol.v1.IndexerAssetPosition updated_asset_positions = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_updated_asset_positions_size()); i < n; i++) {
    const auto& repfield = this->_internal_updated_asset_positions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.SubaccountUpdateEventV1)
  return target;
}

::size_t SubaccountUpdateEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.SubaccountUpdateEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .dydxprotocol.indexer.protocol.v1.IndexerPerpetualPosition updated_perpetual_positions = 3;
  total_size += 1UL * this->_internal_updated_perpetual_positions_size();
  for (const auto& msg : this->_internal_updated_perpetual_positions()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .dydxprotocol.indexer.protocol.v1.IndexerAssetPosition updated_asset_positions = 4;
  total_size += 1UL * this->_internal_updated_asset_positions_size();
  for (const auto& msg : this->_internal_updated_asset_positions()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .dydxprotocol.indexer.protocol.v1.IndexerSubaccountId subaccount_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.subaccount_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountUpdateEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountUpdateEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountUpdateEventV1::GetClassData() const { return &_class_data_; }


void SubaccountUpdateEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountUpdateEventV1*>(&to_msg);
  auto& from = static_cast<const SubaccountUpdateEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.SubaccountUpdateEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_updated_perpetual_positions()->MergeFrom(from._internal_updated_perpetual_positions());
  _this->_internal_mutable_updated_asset_positions()->MergeFrom(from._internal_updated_asset_positions());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_subaccount_id()->::dydxprotocol::indexer::protocol::v1::IndexerSubaccountId::MergeFrom(
        from._internal_subaccount_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountUpdateEventV1::CopyFrom(const SubaccountUpdateEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.SubaccountUpdateEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountUpdateEventV1::IsInitialized() const {
  return true;
}

void SubaccountUpdateEventV1::InternalSwap(SubaccountUpdateEventV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_updated_perpetual_positions()->InternalSwap(other->_internal_mutable_updated_perpetual_positions());
  _internal_mutable_updated_asset_positions()->InternalSwap(other->_internal_mutable_updated_asset_positions());
  swap(_impl_.subaccount_id_, other->_impl_.subaccount_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountUpdateEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[11]);
}
// ===================================================================

class StatefulOrderEventV1_StatefulOrderPlacementV1::_Internal {
 public:
  using HasBits = decltype(std::declval<StatefulOrderEventV1_StatefulOrderPlacementV1>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StatefulOrderEventV1_StatefulOrderPlacementV1, _impl_._has_bits_);
  static const ::dydxprotocol::indexer::protocol::v1::IndexerOrder& order(const StatefulOrderEventV1_StatefulOrderPlacementV1* msg);
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::dydxprotocol::indexer::protocol::v1::IndexerOrder&
StatefulOrderEventV1_StatefulOrderPlacementV1::_Internal::order(const StatefulOrderEventV1_StatefulOrderPlacementV1* msg) {
  return *msg->_impl_.order_;
}
void StatefulOrderEventV1_StatefulOrderPlacementV1::clear_order() {
  if (_impl_.order_ != nullptr) _impl_.order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
StatefulOrderEventV1_StatefulOrderPlacementV1::StatefulOrderEventV1_StatefulOrderPlacementV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1)
}
StatefulOrderEventV1_StatefulOrderPlacementV1::StatefulOrderEventV1_StatefulOrderPlacementV1(const StatefulOrderEventV1_StatefulOrderPlacementV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatefulOrderEventV1_StatefulOrderPlacementV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.order_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.order_ = new ::dydxprotocol::indexer::protocol::v1::IndexerOrder(*from._impl_.order_);
  }
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1)
}

inline void StatefulOrderEventV1_StatefulOrderPlacementV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.order_){nullptr}
  };
}

StatefulOrderEventV1_StatefulOrderPlacementV1::~StatefulOrderEventV1_StatefulOrderPlacementV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatefulOrderEventV1_StatefulOrderPlacementV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.order_;
}

void StatefulOrderEventV1_StatefulOrderPlacementV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatefulOrderEventV1_StatefulOrderPlacementV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.order_ != nullptr);
    _impl_.order_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatefulOrderEventV1_StatefulOrderPlacementV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dydxprotocol.indexer.protocol.v1.IndexerOrder order = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatefulOrderEventV1_StatefulOrderPlacementV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .dydxprotocol.indexer.protocol.v1.IndexerOrder order = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::order(this),
        _Internal::order(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1)
  return target;
}

::size_t StatefulOrderEventV1_StatefulOrderPlacementV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dydxprotocol.indexer.protocol.v1.IndexerOrder order = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.order_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatefulOrderEventV1_StatefulOrderPlacementV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatefulOrderEventV1_StatefulOrderPlacementV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatefulOrderEventV1_StatefulOrderPlacementV1::GetClassData() const { return &_class_data_; }


void StatefulOrderEventV1_StatefulOrderPlacementV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatefulOrderEventV1_StatefulOrderPlacementV1*>(&to_msg);
  auto& from = static_cast<const StatefulOrderEventV1_StatefulOrderPlacementV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_order()->::dydxprotocol::indexer::protocol::v1::IndexerOrder::MergeFrom(
        from._internal_order());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatefulOrderEventV1_StatefulOrderPlacementV1::CopyFrom(const StatefulOrderEventV1_StatefulOrderPlacementV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatefulOrderEventV1_StatefulOrderPlacementV1::IsInitialized() const {
  return true;
}

void StatefulOrderEventV1_StatefulOrderPlacementV1::InternalSwap(StatefulOrderEventV1_StatefulOrderPlacementV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.order_, other->_impl_.order_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatefulOrderEventV1_StatefulOrderPlacementV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[12]);
}
// ===================================================================

class StatefulOrderEventV1_StatefulOrderRemovalV1::_Internal {
 public:
  using HasBits = decltype(std::declval<StatefulOrderEventV1_StatefulOrderRemovalV1>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StatefulOrderEventV1_StatefulOrderRemovalV1, _impl_._has_bits_);
  static const ::dydxprotocol::indexer::protocol::v1::IndexerOrderId& removed_order_id(const StatefulOrderEventV1_StatefulOrderRemovalV1* msg);
  static void set_has_removed_order_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::dydxprotocol::indexer::protocol::v1::IndexerOrderId&
StatefulOrderEventV1_StatefulOrderRemovalV1::_Internal::removed_order_id(const StatefulOrderEventV1_StatefulOrderRemovalV1* msg) {
  return *msg->_impl_.removed_order_id_;
}
void StatefulOrderEventV1_StatefulOrderRemovalV1::clear_removed_order_id() {
  if (_impl_.removed_order_id_ != nullptr) _impl_.removed_order_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
StatefulOrderEventV1_StatefulOrderRemovalV1::StatefulOrderEventV1_StatefulOrderRemovalV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderRemovalV1)
}
StatefulOrderEventV1_StatefulOrderRemovalV1::StatefulOrderEventV1_StatefulOrderRemovalV1(const StatefulOrderEventV1_StatefulOrderRemovalV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatefulOrderEventV1_StatefulOrderRemovalV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.removed_order_id_){nullptr}
    , decltype(_impl_.reason_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.removed_order_id_ = new ::dydxprotocol::indexer::protocol::v1::IndexerOrderId(*from._impl_.removed_order_id_);
  }
  _this->_impl_.reason_ = from._impl_.reason_;
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderRemovalV1)
}

inline void StatefulOrderEventV1_StatefulOrderRemovalV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.removed_order_id_){nullptr}
    , decltype(_impl_.reason_) { 0 }

  };
}

StatefulOrderEventV1_StatefulOrderRemovalV1::~StatefulOrderEventV1_StatefulOrderRemovalV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderRemovalV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatefulOrderEventV1_StatefulOrderRemovalV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.removed_order_id_;
}

void StatefulOrderEventV1_StatefulOrderRemovalV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatefulOrderEventV1_StatefulOrderRemovalV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderRemovalV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.removed_order_id_ != nullptr);
    _impl_.removed_order_id_->Clear();
  }
  _impl_.reason_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatefulOrderEventV1_StatefulOrderRemovalV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dydxprotocol.indexer.protocol.v1.IndexerOrderId removed_order_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_removed_order_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.shared.OrderRemovalReason reason = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_reason(static_cast<::dydxprotocol::indexer::shared::OrderRemovalReason>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatefulOrderEventV1_StatefulOrderRemovalV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderRemovalV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .dydxprotocol.indexer.protocol.v1.IndexerOrderId removed_order_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::removed_order_id(this),
        _Internal::removed_order_id(this).GetCachedSize(), target, stream);
  }

  // .dydxprotocol.indexer.shared.OrderRemovalReason reason = 2;
  if (this->_internal_reason() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderRemovalV1)
  return target;
}

::size_t StatefulOrderEventV1_StatefulOrderRemovalV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderRemovalV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dydxprotocol.indexer.protocol.v1.IndexerOrderId removed_order_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.removed_order_id_);
  }

  // .dydxprotocol.indexer.shared.OrderRemovalReason reason = 2;
  if (this->_internal_reason() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_reason());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatefulOrderEventV1_StatefulOrderRemovalV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatefulOrderEventV1_StatefulOrderRemovalV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatefulOrderEventV1_StatefulOrderRemovalV1::GetClassData() const { return &_class_data_; }


void StatefulOrderEventV1_StatefulOrderRemovalV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatefulOrderEventV1_StatefulOrderRemovalV1*>(&to_msg);
  auto& from = static_cast<const StatefulOrderEventV1_StatefulOrderRemovalV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderRemovalV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_removed_order_id()->::dydxprotocol::indexer::protocol::v1::IndexerOrderId::MergeFrom(
        from._internal_removed_order_id());
  }
  if (from._internal_reason() != 0) {
    _this->_internal_set_reason(from._internal_reason());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatefulOrderEventV1_StatefulOrderRemovalV1::CopyFrom(const StatefulOrderEventV1_StatefulOrderRemovalV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderRemovalV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatefulOrderEventV1_StatefulOrderRemovalV1::IsInitialized() const {
  return true;
}

void StatefulOrderEventV1_StatefulOrderRemovalV1::InternalSwap(StatefulOrderEventV1_StatefulOrderRemovalV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatefulOrderEventV1_StatefulOrderRemovalV1, _impl_.reason_)
      + sizeof(StatefulOrderEventV1_StatefulOrderRemovalV1::_impl_.reason_)
      - PROTOBUF_FIELD_OFFSET(StatefulOrderEventV1_StatefulOrderRemovalV1, _impl_.removed_order_id_)>(
          reinterpret_cast<char*>(&_impl_.removed_order_id_),
          reinterpret_cast<char*>(&other->_impl_.removed_order_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatefulOrderEventV1_StatefulOrderRemovalV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[13]);
}
// ===================================================================

class StatefulOrderEventV1_ConditionalOrderPlacementV1::_Internal {
 public:
  using HasBits = decltype(std::declval<StatefulOrderEventV1_ConditionalOrderPlacementV1>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StatefulOrderEventV1_ConditionalOrderPlacementV1, _impl_._has_bits_);
  static const ::dydxprotocol::indexer::protocol::v1::IndexerOrder& order(const StatefulOrderEventV1_ConditionalOrderPlacementV1* msg);
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::dydxprotocol::indexer::protocol::v1::IndexerOrder&
StatefulOrderEventV1_ConditionalOrderPlacementV1::_Internal::order(const StatefulOrderEventV1_ConditionalOrderPlacementV1* msg) {
  return *msg->_impl_.order_;
}
void StatefulOrderEventV1_ConditionalOrderPlacementV1::clear_order() {
  if (_impl_.order_ != nullptr) _impl_.order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
StatefulOrderEventV1_ConditionalOrderPlacementV1::StatefulOrderEventV1_ConditionalOrderPlacementV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderPlacementV1)
}
StatefulOrderEventV1_ConditionalOrderPlacementV1::StatefulOrderEventV1_ConditionalOrderPlacementV1(const StatefulOrderEventV1_ConditionalOrderPlacementV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatefulOrderEventV1_ConditionalOrderPlacementV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.order_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.order_ = new ::dydxprotocol::indexer::protocol::v1::IndexerOrder(*from._impl_.order_);
  }
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderPlacementV1)
}

inline void StatefulOrderEventV1_ConditionalOrderPlacementV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.order_){nullptr}
  };
}

StatefulOrderEventV1_ConditionalOrderPlacementV1::~StatefulOrderEventV1_ConditionalOrderPlacementV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderPlacementV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatefulOrderEventV1_ConditionalOrderPlacementV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.order_;
}

void StatefulOrderEventV1_ConditionalOrderPlacementV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatefulOrderEventV1_ConditionalOrderPlacementV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderPlacementV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.order_ != nullptr);
    _impl_.order_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatefulOrderEventV1_ConditionalOrderPlacementV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dydxprotocol.indexer.protocol.v1.IndexerOrder order = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatefulOrderEventV1_ConditionalOrderPlacementV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderPlacementV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .dydxprotocol.indexer.protocol.v1.IndexerOrder order = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::order(this),
        _Internal::order(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderPlacementV1)
  return target;
}

::size_t StatefulOrderEventV1_ConditionalOrderPlacementV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderPlacementV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dydxprotocol.indexer.protocol.v1.IndexerOrder order = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.order_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatefulOrderEventV1_ConditionalOrderPlacementV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatefulOrderEventV1_ConditionalOrderPlacementV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatefulOrderEventV1_ConditionalOrderPlacementV1::GetClassData() const { return &_class_data_; }


void StatefulOrderEventV1_ConditionalOrderPlacementV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatefulOrderEventV1_ConditionalOrderPlacementV1*>(&to_msg);
  auto& from = static_cast<const StatefulOrderEventV1_ConditionalOrderPlacementV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderPlacementV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_order()->::dydxprotocol::indexer::protocol::v1::IndexerOrder::MergeFrom(
        from._internal_order());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatefulOrderEventV1_ConditionalOrderPlacementV1::CopyFrom(const StatefulOrderEventV1_ConditionalOrderPlacementV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderPlacementV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatefulOrderEventV1_ConditionalOrderPlacementV1::IsInitialized() const {
  return true;
}

void StatefulOrderEventV1_ConditionalOrderPlacementV1::InternalSwap(StatefulOrderEventV1_ConditionalOrderPlacementV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.order_, other->_impl_.order_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatefulOrderEventV1_ConditionalOrderPlacementV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[14]);
}
// ===================================================================

class StatefulOrderEventV1_ConditionalOrderTriggeredV1::_Internal {
 public:
  using HasBits = decltype(std::declval<StatefulOrderEventV1_ConditionalOrderTriggeredV1>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StatefulOrderEventV1_ConditionalOrderTriggeredV1, _impl_._has_bits_);
  static const ::dydxprotocol::indexer::protocol::v1::IndexerOrderId& triggered_order_id(const StatefulOrderEventV1_ConditionalOrderTriggeredV1* msg);
  static void set_has_triggered_order_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::dydxprotocol::indexer::protocol::v1::IndexerOrderId&
StatefulOrderEventV1_ConditionalOrderTriggeredV1::_Internal::triggered_order_id(const StatefulOrderEventV1_ConditionalOrderTriggeredV1* msg) {
  return *msg->_impl_.triggered_order_id_;
}
void StatefulOrderEventV1_ConditionalOrderTriggeredV1::clear_triggered_order_id() {
  if (_impl_.triggered_order_id_ != nullptr) _impl_.triggered_order_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
StatefulOrderEventV1_ConditionalOrderTriggeredV1::StatefulOrderEventV1_ConditionalOrderTriggeredV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderTriggeredV1)
}
StatefulOrderEventV1_ConditionalOrderTriggeredV1::StatefulOrderEventV1_ConditionalOrderTriggeredV1(const StatefulOrderEventV1_ConditionalOrderTriggeredV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatefulOrderEventV1_ConditionalOrderTriggeredV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.triggered_order_id_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.triggered_order_id_ = new ::dydxprotocol::indexer::protocol::v1::IndexerOrderId(*from._impl_.triggered_order_id_);
  }
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderTriggeredV1)
}

inline void StatefulOrderEventV1_ConditionalOrderTriggeredV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.triggered_order_id_){nullptr}
  };
}

StatefulOrderEventV1_ConditionalOrderTriggeredV1::~StatefulOrderEventV1_ConditionalOrderTriggeredV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderTriggeredV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatefulOrderEventV1_ConditionalOrderTriggeredV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.triggered_order_id_;
}

void StatefulOrderEventV1_ConditionalOrderTriggeredV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatefulOrderEventV1_ConditionalOrderTriggeredV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderTriggeredV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.triggered_order_id_ != nullptr);
    _impl_.triggered_order_id_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatefulOrderEventV1_ConditionalOrderTriggeredV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dydxprotocol.indexer.protocol.v1.IndexerOrderId triggered_order_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_triggered_order_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatefulOrderEventV1_ConditionalOrderTriggeredV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderTriggeredV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .dydxprotocol.indexer.protocol.v1.IndexerOrderId triggered_order_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::triggered_order_id(this),
        _Internal::triggered_order_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderTriggeredV1)
  return target;
}

::size_t StatefulOrderEventV1_ConditionalOrderTriggeredV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderTriggeredV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dydxprotocol.indexer.protocol.v1.IndexerOrderId triggered_order_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.triggered_order_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatefulOrderEventV1_ConditionalOrderTriggeredV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatefulOrderEventV1_ConditionalOrderTriggeredV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatefulOrderEventV1_ConditionalOrderTriggeredV1::GetClassData() const { return &_class_data_; }


void StatefulOrderEventV1_ConditionalOrderTriggeredV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatefulOrderEventV1_ConditionalOrderTriggeredV1*>(&to_msg);
  auto& from = static_cast<const StatefulOrderEventV1_ConditionalOrderTriggeredV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderTriggeredV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_triggered_order_id()->::dydxprotocol::indexer::protocol::v1::IndexerOrderId::MergeFrom(
        from._internal_triggered_order_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatefulOrderEventV1_ConditionalOrderTriggeredV1::CopyFrom(const StatefulOrderEventV1_ConditionalOrderTriggeredV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderTriggeredV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatefulOrderEventV1_ConditionalOrderTriggeredV1::IsInitialized() const {
  return true;
}

void StatefulOrderEventV1_ConditionalOrderTriggeredV1::InternalSwap(StatefulOrderEventV1_ConditionalOrderTriggeredV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.triggered_order_id_, other->_impl_.triggered_order_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatefulOrderEventV1_ConditionalOrderTriggeredV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[15]);
}
// ===================================================================

class StatefulOrderEventV1_LongTermOrderPlacementV1::_Internal {
 public:
  using HasBits = decltype(std::declval<StatefulOrderEventV1_LongTermOrderPlacementV1>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StatefulOrderEventV1_LongTermOrderPlacementV1, _impl_._has_bits_);
  static const ::dydxprotocol::indexer::protocol::v1::IndexerOrder& order(const StatefulOrderEventV1_LongTermOrderPlacementV1* msg);
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::dydxprotocol::indexer::protocol::v1::IndexerOrder&
StatefulOrderEventV1_LongTermOrderPlacementV1::_Internal::order(const StatefulOrderEventV1_LongTermOrderPlacementV1* msg) {
  return *msg->_impl_.order_;
}
void StatefulOrderEventV1_LongTermOrderPlacementV1::clear_order() {
  if (_impl_.order_ != nullptr) _impl_.order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
StatefulOrderEventV1_LongTermOrderPlacementV1::StatefulOrderEventV1_LongTermOrderPlacementV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderPlacementV1)
}
StatefulOrderEventV1_LongTermOrderPlacementV1::StatefulOrderEventV1_LongTermOrderPlacementV1(const StatefulOrderEventV1_LongTermOrderPlacementV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatefulOrderEventV1_LongTermOrderPlacementV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.order_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.order_ = new ::dydxprotocol::indexer::protocol::v1::IndexerOrder(*from._impl_.order_);
  }
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderPlacementV1)
}

inline void StatefulOrderEventV1_LongTermOrderPlacementV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.order_){nullptr}
  };
}

StatefulOrderEventV1_LongTermOrderPlacementV1::~StatefulOrderEventV1_LongTermOrderPlacementV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderPlacementV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatefulOrderEventV1_LongTermOrderPlacementV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.order_;
}

void StatefulOrderEventV1_LongTermOrderPlacementV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatefulOrderEventV1_LongTermOrderPlacementV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderPlacementV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.order_ != nullptr);
    _impl_.order_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatefulOrderEventV1_LongTermOrderPlacementV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dydxprotocol.indexer.protocol.v1.IndexerOrder order = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatefulOrderEventV1_LongTermOrderPlacementV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderPlacementV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .dydxprotocol.indexer.protocol.v1.IndexerOrder order = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::order(this),
        _Internal::order(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderPlacementV1)
  return target;
}

::size_t StatefulOrderEventV1_LongTermOrderPlacementV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderPlacementV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dydxprotocol.indexer.protocol.v1.IndexerOrder order = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.order_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatefulOrderEventV1_LongTermOrderPlacementV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatefulOrderEventV1_LongTermOrderPlacementV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatefulOrderEventV1_LongTermOrderPlacementV1::GetClassData() const { return &_class_data_; }


void StatefulOrderEventV1_LongTermOrderPlacementV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatefulOrderEventV1_LongTermOrderPlacementV1*>(&to_msg);
  auto& from = static_cast<const StatefulOrderEventV1_LongTermOrderPlacementV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderPlacementV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_order()->::dydxprotocol::indexer::protocol::v1::IndexerOrder::MergeFrom(
        from._internal_order());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatefulOrderEventV1_LongTermOrderPlacementV1::CopyFrom(const StatefulOrderEventV1_LongTermOrderPlacementV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderPlacementV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatefulOrderEventV1_LongTermOrderPlacementV1::IsInitialized() const {
  return true;
}

void StatefulOrderEventV1_LongTermOrderPlacementV1::InternalSwap(StatefulOrderEventV1_LongTermOrderPlacementV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.order_, other->_impl_.order_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatefulOrderEventV1_LongTermOrderPlacementV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[16]);
}
// ===================================================================

class StatefulOrderEventV1::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::dydxprotocol::indexer::events::StatefulOrderEventV1, _impl_._oneof_case_);
  static const ::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderPlacementV1& order_place(const StatefulOrderEventV1* msg);
  static const ::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderRemovalV1& order_removal(const StatefulOrderEventV1* msg);
  static const ::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderPlacementV1& conditional_order_placement(const StatefulOrderEventV1* msg);
  static const ::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderTriggeredV1& conditional_order_triggered(const StatefulOrderEventV1* msg);
  static const ::dydxprotocol::indexer::events::StatefulOrderEventV1_LongTermOrderPlacementV1& long_term_order_placement(const StatefulOrderEventV1* msg);
};

const ::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderPlacementV1&
StatefulOrderEventV1::_Internal::order_place(const StatefulOrderEventV1* msg) {
  return *msg->_impl_.event_.order_place_;
}
const ::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderRemovalV1&
StatefulOrderEventV1::_Internal::order_removal(const StatefulOrderEventV1* msg) {
  return *msg->_impl_.event_.order_removal_;
}
const ::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderPlacementV1&
StatefulOrderEventV1::_Internal::conditional_order_placement(const StatefulOrderEventV1* msg) {
  return *msg->_impl_.event_.conditional_order_placement_;
}
const ::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderTriggeredV1&
StatefulOrderEventV1::_Internal::conditional_order_triggered(const StatefulOrderEventV1* msg) {
  return *msg->_impl_.event_.conditional_order_triggered_;
}
const ::dydxprotocol::indexer::events::StatefulOrderEventV1_LongTermOrderPlacementV1&
StatefulOrderEventV1::_Internal::long_term_order_placement(const StatefulOrderEventV1* msg) {
  return *msg->_impl_.event_.long_term_order_placement_;
}
void StatefulOrderEventV1::set_allocated_order_place(::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderPlacementV1* order_place) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_event();
  if (order_place) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order_place);
    if (message_arena != submessage_arena) {
      order_place = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order_place, submessage_arena);
    }
    set_has_order_place();
    _impl_.event_.order_place_ = order_place;
  }
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.events.StatefulOrderEventV1.order_place)
}
void StatefulOrderEventV1::set_allocated_order_removal(::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderRemovalV1* order_removal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_event();
  if (order_removal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order_removal);
    if (message_arena != submessage_arena) {
      order_removal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order_removal, submessage_arena);
    }
    set_has_order_removal();
    _impl_.event_.order_removal_ = order_removal;
  }
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.events.StatefulOrderEventV1.order_removal)
}
void StatefulOrderEventV1::set_allocated_conditional_order_placement(::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderPlacementV1* conditional_order_placement) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_event();
  if (conditional_order_placement) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conditional_order_placement);
    if (message_arena != submessage_arena) {
      conditional_order_placement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conditional_order_placement, submessage_arena);
    }
    set_has_conditional_order_placement();
    _impl_.event_.conditional_order_placement_ = conditional_order_placement;
  }
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.events.StatefulOrderEventV1.conditional_order_placement)
}
void StatefulOrderEventV1::set_allocated_conditional_order_triggered(::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderTriggeredV1* conditional_order_triggered) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_event();
  if (conditional_order_triggered) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conditional_order_triggered);
    if (message_arena != submessage_arena) {
      conditional_order_triggered = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conditional_order_triggered, submessage_arena);
    }
    set_has_conditional_order_triggered();
    _impl_.event_.conditional_order_triggered_ = conditional_order_triggered;
  }
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.events.StatefulOrderEventV1.conditional_order_triggered)
}
void StatefulOrderEventV1::set_allocated_long_term_order_placement(::dydxprotocol::indexer::events::StatefulOrderEventV1_LongTermOrderPlacementV1* long_term_order_placement) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_event();
  if (long_term_order_placement) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(long_term_order_placement);
    if (message_arena != submessage_arena) {
      long_term_order_placement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, long_term_order_placement, submessage_arena);
    }
    set_has_long_term_order_placement();
    _impl_.event_.long_term_order_placement_ = long_term_order_placement;
  }
  // @@protoc_insertion_point(field_set_allocated:dydxprotocol.indexer.events.StatefulOrderEventV1.long_term_order_placement)
}
StatefulOrderEventV1::StatefulOrderEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.StatefulOrderEventV1)
}
StatefulOrderEventV1::StatefulOrderEventV1(const StatefulOrderEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatefulOrderEventV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.event_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_event();
  switch (from.event_case()) {
    case kOrderPlace: {
      _this->_internal_mutable_order_place()->::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderPlacementV1::MergeFrom(
          from._internal_order_place());
      break;
    }
    case kOrderRemoval: {
      _this->_internal_mutable_order_removal()->::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderRemovalV1::MergeFrom(
          from._internal_order_removal());
      break;
    }
    case kConditionalOrderPlacement: {
      _this->_internal_mutable_conditional_order_placement()->::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderPlacementV1::MergeFrom(
          from._internal_conditional_order_placement());
      break;
    }
    case kConditionalOrderTriggered: {
      _this->_internal_mutable_conditional_order_triggered()->::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderTriggeredV1::MergeFrom(
          from._internal_conditional_order_triggered());
      break;
    }
    case kLongTermOrderPlacement: {
      _this->_internal_mutable_long_term_order_placement()->::dydxprotocol::indexer::events::StatefulOrderEventV1_LongTermOrderPlacementV1::MergeFrom(
          from._internal_long_term_order_placement());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.StatefulOrderEventV1)
}

inline void StatefulOrderEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.event_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_event();
}

StatefulOrderEventV1::~StatefulOrderEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.StatefulOrderEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatefulOrderEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_event()) {
    clear_event();
  }
}

void StatefulOrderEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatefulOrderEventV1::clear_event() {
// @@protoc_insertion_point(one_of_clear_start:dydxprotocol.indexer.events.StatefulOrderEventV1)
  switch (event_case()) {
    case kOrderPlace: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.event_.order_place_;
      }
      break;
    }
    case kOrderRemoval: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.event_.order_removal_;
      }
      break;
    }
    case kConditionalOrderPlacement: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.event_.conditional_order_placement_;
      }
      break;
    }
    case kConditionalOrderTriggered: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.event_.conditional_order_triggered_;
      }
      break;
    }
    case kLongTermOrderPlacement: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.event_.long_term_order_placement_;
      }
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}


void StatefulOrderEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.StatefulOrderEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_event();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatefulOrderEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1 order_place = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_order_place(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderRemovalV1 order_removal = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_order_removal(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderPlacementV1 conditional_order_placement = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_conditional_order_placement(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderTriggeredV1 conditional_order_triggered = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_conditional_order_triggered(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderPlacementV1 long_term_order_placement = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_long_term_order_placement(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatefulOrderEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.StatefulOrderEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (event_case()) {
    case kOrderPlace: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::order_place(this),
          _Internal::order_place(this).GetCachedSize(), target, stream);
      break;
    }
    case kOrderRemoval: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::order_removal(this),
          _Internal::order_removal(this).GetCachedSize(), target, stream);
      break;
    }
    case kConditionalOrderPlacement: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::conditional_order_placement(this),
          _Internal::conditional_order_placement(this).GetCachedSize(), target, stream);
      break;
    }
    case kConditionalOrderTriggered: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::conditional_order_triggered(this),
          _Internal::conditional_order_triggered(this).GetCachedSize(), target, stream);
      break;
    }
    case kLongTermOrderPlacement: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::long_term_order_placement(this),
          _Internal::long_term_order_placement(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.StatefulOrderEventV1)
  return target;
}

::size_t StatefulOrderEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.StatefulOrderEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (event_case()) {
    // .dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1 order_place = 1;
    case kOrderPlace: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.event_.order_place_);
      break;
    }
    // .dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderRemovalV1 order_removal = 4;
    case kOrderRemoval: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.event_.order_removal_);
      break;
    }
    // .dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderPlacementV1 conditional_order_placement = 5;
    case kConditionalOrderPlacement: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.event_.conditional_order_placement_);
      break;
    }
    // .dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderTriggeredV1 conditional_order_triggered = 6;
    case kConditionalOrderTriggered: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.event_.conditional_order_triggered_);
      break;
    }
    // .dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderPlacementV1 long_term_order_placement = 7;
    case kLongTermOrderPlacement: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.event_.long_term_order_placement_);
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatefulOrderEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatefulOrderEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatefulOrderEventV1::GetClassData() const { return &_class_data_; }


void StatefulOrderEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatefulOrderEventV1*>(&to_msg);
  auto& from = static_cast<const StatefulOrderEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.StatefulOrderEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.event_case()) {
    case kOrderPlace: {
      _this->_internal_mutable_order_place()->::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderPlacementV1::MergeFrom(
          from._internal_order_place());
      break;
    }
    case kOrderRemoval: {
      _this->_internal_mutable_order_removal()->::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderRemovalV1::MergeFrom(
          from._internal_order_removal());
      break;
    }
    case kConditionalOrderPlacement: {
      _this->_internal_mutable_conditional_order_placement()->::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderPlacementV1::MergeFrom(
          from._internal_conditional_order_placement());
      break;
    }
    case kConditionalOrderTriggered: {
      _this->_internal_mutable_conditional_order_triggered()->::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderTriggeredV1::MergeFrom(
          from._internal_conditional_order_triggered());
      break;
    }
    case kLongTermOrderPlacement: {
      _this->_internal_mutable_long_term_order_placement()->::dydxprotocol::indexer::events::StatefulOrderEventV1_LongTermOrderPlacementV1::MergeFrom(
          from._internal_long_term_order_placement());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatefulOrderEventV1::CopyFrom(const StatefulOrderEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.StatefulOrderEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatefulOrderEventV1::IsInitialized() const {
  return true;
}

void StatefulOrderEventV1::InternalSwap(StatefulOrderEventV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.event_, other->_impl_.event_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatefulOrderEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[17]);
}
// ===================================================================

class AssetCreateEventV1::_Internal {
 public:
};

AssetCreateEventV1::AssetCreateEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.AssetCreateEventV1)
}
AssetCreateEventV1::AssetCreateEventV1(const AssetCreateEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AssetCreateEventV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.symbol_) {}

    , decltype(_impl_.id_) {}

    , decltype(_impl_.has_market_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.atomic_resolution_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.symbol_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_symbol().empty()) {
    _this->_impl_.symbol_.Set(from._internal_symbol(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.atomic_resolution_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.atomic_resolution_));
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.AssetCreateEventV1)
}

inline void AssetCreateEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.symbol_) {}

    , decltype(_impl_.id_) { 0u }

    , decltype(_impl_.has_market_) { false }

    , decltype(_impl_.market_id_) { 0u }

    , decltype(_impl_.atomic_resolution_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.symbol_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AssetCreateEventV1::~AssetCreateEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.AssetCreateEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AssetCreateEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.symbol_.Destroy();
}

void AssetCreateEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AssetCreateEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.AssetCreateEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.symbol_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.atomic_resolution_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.atomic_resolution_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AssetCreateEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string symbol = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_symbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "dydxprotocol.indexer.events.AssetCreateEventV1.symbol"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool has_market = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.has_market_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 market_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.market_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 atomic_resolution = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.atomic_resolution_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AssetCreateEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.AssetCreateEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_id(), target);
  }

  // string symbol = 2;
  if (!this->_internal_symbol().empty()) {
    const std::string& _s = this->_internal_symbol();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "dydxprotocol.indexer.events.AssetCreateEventV1.symbol");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // bool has_market = 3;
  if (this->_internal_has_market() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_has_market(), target);
  }

  // uint32 market_id = 4;
  if (this->_internal_market_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_market_id(), target);
  }

  // sint32 atomic_resolution = 5;
  if (this->_internal_atomic_resolution() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        5, this->_internal_atomic_resolution(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.AssetCreateEventV1)
  return target;
}

::size_t AssetCreateEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.AssetCreateEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string symbol = 2;
  if (!this->_internal_symbol().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_symbol());
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_id());
  }

  // bool has_market = 3;
  if (this->_internal_has_market() != 0) {
    total_size += 2;
  }

  // uint32 market_id = 4;
  if (this->_internal_market_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_market_id());
  }

  // sint32 atomic_resolution = 5;
  if (this->_internal_atomic_resolution() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_atomic_resolution());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AssetCreateEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AssetCreateEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AssetCreateEventV1::GetClassData() const { return &_class_data_; }


void AssetCreateEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AssetCreateEventV1*>(&to_msg);
  auto& from = static_cast<const AssetCreateEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.AssetCreateEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_symbol().empty()) {
    _this->_internal_set_symbol(from._internal_symbol());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_has_market() != 0) {
    _this->_internal_set_has_market(from._internal_has_market());
  }
  if (from._internal_market_id() != 0) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (from._internal_atomic_resolution() != 0) {
    _this->_internal_set_atomic_resolution(from._internal_atomic_resolution());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AssetCreateEventV1::CopyFrom(const AssetCreateEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.AssetCreateEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AssetCreateEventV1::IsInitialized() const {
  return true;
}

void AssetCreateEventV1::InternalSwap(AssetCreateEventV1* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.symbol_, lhs_arena,
                                       &other->_impl_.symbol_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AssetCreateEventV1, _impl_.atomic_resolution_)
      + sizeof(AssetCreateEventV1::_impl_.atomic_resolution_)
      - PROTOBUF_FIELD_OFFSET(AssetCreateEventV1, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AssetCreateEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[18]);
}
// ===================================================================

class PerpetualMarketCreateEventV1::_Internal {
 public:
};

PerpetualMarketCreateEventV1::PerpetualMarketCreateEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.PerpetualMarketCreateEventV1)
}
PerpetualMarketCreateEventV1::PerpetualMarketCreateEventV1(const PerpetualMarketCreateEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PerpetualMarketCreateEventV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ticker_) {}

    , decltype(_impl_.id_) {}

    , decltype(_impl_.clob_pair_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.status_) {}

    , decltype(_impl_.quantum_conversion_exponent_) {}

    , decltype(_impl_.atomic_resolution_) {}

    , decltype(_impl_.step_base_quantums_) {}

    , decltype(_impl_.subticks_per_tick_) {}

    , decltype(_impl_.liquidity_tier_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ticker_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ticker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ticker().empty()) {
    _this->_impl_.ticker_.Set(from._internal_ticker(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.liquidity_tier_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.liquidity_tier_));
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.PerpetualMarketCreateEventV1)
}

inline void PerpetualMarketCreateEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ticker_) {}

    , decltype(_impl_.id_) { 0u }

    , decltype(_impl_.clob_pair_id_) { 0u }

    , decltype(_impl_.market_id_) { 0u }

    , decltype(_impl_.status_) { 0 }

    , decltype(_impl_.quantum_conversion_exponent_) { 0 }

    , decltype(_impl_.atomic_resolution_) { 0 }

    , decltype(_impl_.step_base_quantums_) { ::uint64_t{0u} }

    , decltype(_impl_.subticks_per_tick_) { 0u }

    , decltype(_impl_.liquidity_tier_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ticker_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ticker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PerpetualMarketCreateEventV1::~PerpetualMarketCreateEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.PerpetualMarketCreateEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PerpetualMarketCreateEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ticker_.Destroy();
}

void PerpetualMarketCreateEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PerpetualMarketCreateEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.PerpetualMarketCreateEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ticker_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.liquidity_tier_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.liquidity_tier_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PerpetualMarketCreateEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 clob_pair_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.clob_pair_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string ticker = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ticker();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "dydxprotocol.indexer.events.PerpetualMarketCreateEventV1.ticker"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 market_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.market_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.protocol.v1.ClobPairStatus status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::dydxprotocol::indexer::protocol::v1::ClobPairStatus>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 quantum_conversion_exponent = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.quantum_conversion_exponent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 atomic_resolution = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.atomic_resolution_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 subticks_per_tick = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.subticks_per_tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 step_base_quantums = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.step_base_quantums_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 liquidity_tier = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.liquidity_tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PerpetualMarketCreateEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.PerpetualMarketCreateEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_id(), target);
  }

  // uint32 clob_pair_id = 2;
  if (this->_internal_clob_pair_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_clob_pair_id(), target);
  }

  // string ticker = 3;
  if (!this->_internal_ticker().empty()) {
    const std::string& _s = this->_internal_ticker();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "dydxprotocol.indexer.events.PerpetualMarketCreateEventV1.ticker");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // uint32 market_id = 4;
  if (this->_internal_market_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_market_id(), target);
  }

  // .dydxprotocol.indexer.protocol.v1.ClobPairStatus status = 5;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_status(), target);
  }

  // sint32 quantum_conversion_exponent = 6;
  if (this->_internal_quantum_conversion_exponent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        6, this->_internal_quantum_conversion_exponent(), target);
  }

  // sint32 atomic_resolution = 7;
  if (this->_internal_atomic_resolution() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        7, this->_internal_atomic_resolution(), target);
  }

  // uint32 subticks_per_tick = 8;
  if (this->_internal_subticks_per_tick() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_subticks_per_tick(), target);
  }

  // uint64 step_base_quantums = 9;
  if (this->_internal_step_base_quantums() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        9, this->_internal_step_base_quantums(), target);
  }

  // uint32 liquidity_tier = 10;
  if (this->_internal_liquidity_tier() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        10, this->_internal_liquidity_tier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.PerpetualMarketCreateEventV1)
  return target;
}

::size_t PerpetualMarketCreateEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.PerpetualMarketCreateEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ticker = 3;
  if (!this->_internal_ticker().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_ticker());
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_id());
  }

  // uint32 clob_pair_id = 2;
  if (this->_internal_clob_pair_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_clob_pair_id());
  }

  // uint32 market_id = 4;
  if (this->_internal_market_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_market_id());
  }

  // .dydxprotocol.indexer.protocol.v1.ClobPairStatus status = 5;
  if (this->_internal_status() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  // sint32 quantum_conversion_exponent = 6;
  if (this->_internal_quantum_conversion_exponent() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_quantum_conversion_exponent());
  }

  // sint32 atomic_resolution = 7;
  if (this->_internal_atomic_resolution() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_atomic_resolution());
  }

  // uint64 step_base_quantums = 9;
  if (this->_internal_step_base_quantums() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_step_base_quantums());
  }

  // uint32 subticks_per_tick = 8;
  if (this->_internal_subticks_per_tick() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_subticks_per_tick());
  }

  // uint32 liquidity_tier = 10;
  if (this->_internal_liquidity_tier() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_liquidity_tier());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PerpetualMarketCreateEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PerpetualMarketCreateEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PerpetualMarketCreateEventV1::GetClassData() const { return &_class_data_; }


void PerpetualMarketCreateEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PerpetualMarketCreateEventV1*>(&to_msg);
  auto& from = static_cast<const PerpetualMarketCreateEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.PerpetualMarketCreateEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ticker().empty()) {
    _this->_internal_set_ticker(from._internal_ticker());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_clob_pair_id() != 0) {
    _this->_internal_set_clob_pair_id(from._internal_clob_pair_id());
  }
  if (from._internal_market_id() != 0) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  if (from._internal_quantum_conversion_exponent() != 0) {
    _this->_internal_set_quantum_conversion_exponent(from._internal_quantum_conversion_exponent());
  }
  if (from._internal_atomic_resolution() != 0) {
    _this->_internal_set_atomic_resolution(from._internal_atomic_resolution());
  }
  if (from._internal_step_base_quantums() != 0) {
    _this->_internal_set_step_base_quantums(from._internal_step_base_quantums());
  }
  if (from._internal_subticks_per_tick() != 0) {
    _this->_internal_set_subticks_per_tick(from._internal_subticks_per_tick());
  }
  if (from._internal_liquidity_tier() != 0) {
    _this->_internal_set_liquidity_tier(from._internal_liquidity_tier());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PerpetualMarketCreateEventV1::CopyFrom(const PerpetualMarketCreateEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.PerpetualMarketCreateEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PerpetualMarketCreateEventV1::IsInitialized() const {
  return true;
}

void PerpetualMarketCreateEventV1::InternalSwap(PerpetualMarketCreateEventV1* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ticker_, lhs_arena,
                                       &other->_impl_.ticker_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PerpetualMarketCreateEventV1, _impl_.liquidity_tier_)
      + sizeof(PerpetualMarketCreateEventV1::_impl_.liquidity_tier_)
      - PROTOBUF_FIELD_OFFSET(PerpetualMarketCreateEventV1, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PerpetualMarketCreateEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[19]);
}
// ===================================================================

class LiquidityTierUpsertEventV1::_Internal {
 public:
};

LiquidityTierUpsertEventV1::LiquidityTierUpsertEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.LiquidityTierUpsertEventV1)
}
LiquidityTierUpsertEventV1::LiquidityTierUpsertEventV1(const LiquidityTierUpsertEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LiquidityTierUpsertEventV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , decltype(_impl_.id_) {}

    , decltype(_impl_.initial_margin_ppm_) {}

    , decltype(_impl_.base_position_notional_) {}

    , decltype(_impl_.maintenance_fraction_ppm_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.maintenance_fraction_ppm_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.maintenance_fraction_ppm_));
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.LiquidityTierUpsertEventV1)
}

inline void LiquidityTierUpsertEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , decltype(_impl_.id_) { 0u }

    , decltype(_impl_.initial_margin_ppm_) { 0u }

    , decltype(_impl_.base_position_notional_) { ::uint64_t{0u} }

    , decltype(_impl_.maintenance_fraction_ppm_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LiquidityTierUpsertEventV1::~LiquidityTierUpsertEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.LiquidityTierUpsertEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LiquidityTierUpsertEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void LiquidityTierUpsertEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LiquidityTierUpsertEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.LiquidityTierUpsertEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.maintenance_fraction_ppm_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.maintenance_fraction_ppm_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LiquidityTierUpsertEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "dydxprotocol.indexer.events.LiquidityTierUpsertEventV1.name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 initial_margin_ppm = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.initial_margin_ppm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 maintenance_fraction_ppm = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.maintenance_fraction_ppm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 base_position_notional = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.base_position_notional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LiquidityTierUpsertEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.LiquidityTierUpsertEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_id(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "dydxprotocol.indexer.events.LiquidityTierUpsertEventV1.name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // uint32 initial_margin_ppm = 3;
  if (this->_internal_initial_margin_ppm() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_initial_margin_ppm(), target);
  }

  // uint32 maintenance_fraction_ppm = 4;
  if (this->_internal_maintenance_fraction_ppm() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_maintenance_fraction_ppm(), target);
  }

  // uint64 base_position_notional = 5;
  if (this->_internal_base_position_notional() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_base_position_notional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.LiquidityTierUpsertEventV1)
  return target;
}

::size_t LiquidityTierUpsertEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.LiquidityTierUpsertEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_id());
  }

  // uint32 initial_margin_ppm = 3;
  if (this->_internal_initial_margin_ppm() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_initial_margin_ppm());
  }

  // uint64 base_position_notional = 5;
  if (this->_internal_base_position_notional() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_base_position_notional());
  }

  // uint32 maintenance_fraction_ppm = 4;
  if (this->_internal_maintenance_fraction_ppm() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_maintenance_fraction_ppm());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LiquidityTierUpsertEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LiquidityTierUpsertEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LiquidityTierUpsertEventV1::GetClassData() const { return &_class_data_; }


void LiquidityTierUpsertEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LiquidityTierUpsertEventV1*>(&to_msg);
  auto& from = static_cast<const LiquidityTierUpsertEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.LiquidityTierUpsertEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_initial_margin_ppm() != 0) {
    _this->_internal_set_initial_margin_ppm(from._internal_initial_margin_ppm());
  }
  if (from._internal_base_position_notional() != 0) {
    _this->_internal_set_base_position_notional(from._internal_base_position_notional());
  }
  if (from._internal_maintenance_fraction_ppm() != 0) {
    _this->_internal_set_maintenance_fraction_ppm(from._internal_maintenance_fraction_ppm());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LiquidityTierUpsertEventV1::CopyFrom(const LiquidityTierUpsertEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.LiquidityTierUpsertEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LiquidityTierUpsertEventV1::IsInitialized() const {
  return true;
}

void LiquidityTierUpsertEventV1::InternalSwap(LiquidityTierUpsertEventV1* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LiquidityTierUpsertEventV1, _impl_.maintenance_fraction_ppm_)
      + sizeof(LiquidityTierUpsertEventV1::_impl_.maintenance_fraction_ppm_)
      - PROTOBUF_FIELD_OFFSET(LiquidityTierUpsertEventV1, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LiquidityTierUpsertEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[20]);
}
// ===================================================================

class UpdateClobPairEventV1::_Internal {
 public:
};

UpdateClobPairEventV1::UpdateClobPairEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.UpdateClobPairEventV1)
}
UpdateClobPairEventV1::UpdateClobPairEventV1(const UpdateClobPairEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.UpdateClobPairEventV1)
}

inline void UpdateClobPairEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.clob_pair_id_) { 0u }

    , decltype(_impl_.status_) { 0 }

    , decltype(_impl_.quantum_conversion_exponent_) { 0 }

    , decltype(_impl_.subticks_per_tick_) { 0u }

    , decltype(_impl_.step_base_quantums_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateClobPairEventV1::~UpdateClobPairEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.UpdateClobPairEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateClobPairEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void UpdateClobPairEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateClobPairEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.UpdateClobPairEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.clob_pair_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.step_base_quantums_) -
      reinterpret_cast<char*>(&_impl_.clob_pair_id_)) + sizeof(_impl_.step_base_quantums_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateClobPairEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 clob_pair_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.clob_pair_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .dydxprotocol.indexer.protocol.v1.ClobPairStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::dydxprotocol::indexer::protocol::v1::ClobPairStatus>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 quantum_conversion_exponent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.quantum_conversion_exponent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 subticks_per_tick = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.subticks_per_tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 step_base_quantums = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.step_base_quantums_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* UpdateClobPairEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.UpdateClobPairEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 clob_pair_id = 1;
  if (this->_internal_clob_pair_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_clob_pair_id(), target);
  }

  // .dydxprotocol.indexer.protocol.v1.ClobPairStatus status = 2;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_status(), target);
  }

  // sint32 quantum_conversion_exponent = 3;
  if (this->_internal_quantum_conversion_exponent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        3, this->_internal_quantum_conversion_exponent(), target);
  }

  // uint32 subticks_per_tick = 4;
  if (this->_internal_subticks_per_tick() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_subticks_per_tick(), target);
  }

  // uint64 step_base_quantums = 5;
  if (this->_internal_step_base_quantums() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_step_base_quantums(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.UpdateClobPairEventV1)
  return target;
}

::size_t UpdateClobPairEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.UpdateClobPairEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 clob_pair_id = 1;
  if (this->_internal_clob_pair_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_clob_pair_id());
  }

  // .dydxprotocol.indexer.protocol.v1.ClobPairStatus status = 2;
  if (this->_internal_status() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  // sint32 quantum_conversion_exponent = 3;
  if (this->_internal_quantum_conversion_exponent() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_quantum_conversion_exponent());
  }

  // uint32 subticks_per_tick = 4;
  if (this->_internal_subticks_per_tick() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_subticks_per_tick());
  }

  // uint64 step_base_quantums = 5;
  if (this->_internal_step_base_quantums() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_step_base_quantums());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateClobPairEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateClobPairEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateClobPairEventV1::GetClassData() const { return &_class_data_; }


void UpdateClobPairEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateClobPairEventV1*>(&to_msg);
  auto& from = static_cast<const UpdateClobPairEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.UpdateClobPairEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_clob_pair_id() != 0) {
    _this->_internal_set_clob_pair_id(from._internal_clob_pair_id());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  if (from._internal_quantum_conversion_exponent() != 0) {
    _this->_internal_set_quantum_conversion_exponent(from._internal_quantum_conversion_exponent());
  }
  if (from._internal_subticks_per_tick() != 0) {
    _this->_internal_set_subticks_per_tick(from._internal_subticks_per_tick());
  }
  if (from._internal_step_base_quantums() != 0) {
    _this->_internal_set_step_base_quantums(from._internal_step_base_quantums());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateClobPairEventV1::CopyFrom(const UpdateClobPairEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.UpdateClobPairEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateClobPairEventV1::IsInitialized() const {
  return true;
}

void UpdateClobPairEventV1::InternalSwap(UpdateClobPairEventV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateClobPairEventV1, _impl_.step_base_quantums_)
      + sizeof(UpdateClobPairEventV1::_impl_.step_base_quantums_)
      - PROTOBUF_FIELD_OFFSET(UpdateClobPairEventV1, _impl_.clob_pair_id_)>(
          reinterpret_cast<char*>(&_impl_.clob_pair_id_),
          reinterpret_cast<char*>(&other->_impl_.clob_pair_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateClobPairEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[21]);
}
// ===================================================================

class UpdatePerpetualEventV1::_Internal {
 public:
};

UpdatePerpetualEventV1::UpdatePerpetualEventV1(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dydxprotocol.indexer.events.UpdatePerpetualEventV1)
}
UpdatePerpetualEventV1::UpdatePerpetualEventV1(const UpdatePerpetualEventV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdatePerpetualEventV1* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ticker_) {}

    , decltype(_impl_.id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.atomic_resolution_) {}

    , decltype(_impl_.liquidity_tier_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ticker_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ticker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ticker().empty()) {
    _this->_impl_.ticker_.Set(from._internal_ticker(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.liquidity_tier_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.liquidity_tier_));
  // @@protoc_insertion_point(copy_constructor:dydxprotocol.indexer.events.UpdatePerpetualEventV1)
}

inline void UpdatePerpetualEventV1::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ticker_) {}

    , decltype(_impl_.id_) { 0u }

    , decltype(_impl_.market_id_) { 0u }

    , decltype(_impl_.atomic_resolution_) { 0 }

    , decltype(_impl_.liquidity_tier_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ticker_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ticker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UpdatePerpetualEventV1::~UpdatePerpetualEventV1() {
  // @@protoc_insertion_point(destructor:dydxprotocol.indexer.events.UpdatePerpetualEventV1)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdatePerpetualEventV1::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ticker_.Destroy();
}

void UpdatePerpetualEventV1::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdatePerpetualEventV1::Clear() {
// @@protoc_insertion_point(message_clear_start:dydxprotocol.indexer.events.UpdatePerpetualEventV1)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ticker_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.liquidity_tier_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.liquidity_tier_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdatePerpetualEventV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string ticker = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ticker();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "dydxprotocol.indexer.events.UpdatePerpetualEventV1.ticker"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 market_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.market_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 atomic_resolution = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.atomic_resolution_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 liquidity_tier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.liquidity_tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* UpdatePerpetualEventV1::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dydxprotocol.indexer.events.UpdatePerpetualEventV1)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_id(), target);
  }

  // string ticker = 2;
  if (!this->_internal_ticker().empty()) {
    const std::string& _s = this->_internal_ticker();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "dydxprotocol.indexer.events.UpdatePerpetualEventV1.ticker");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // uint32 market_id = 3;
  if (this->_internal_market_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_market_id(), target);
  }

  // sint32 atomic_resolution = 4;
  if (this->_internal_atomic_resolution() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        4, this->_internal_atomic_resolution(), target);
  }

  // uint32 liquidity_tier = 5;
  if (this->_internal_liquidity_tier() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_liquidity_tier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dydxprotocol.indexer.events.UpdatePerpetualEventV1)
  return target;
}

::size_t UpdatePerpetualEventV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dydxprotocol.indexer.events.UpdatePerpetualEventV1)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ticker = 2;
  if (!this->_internal_ticker().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_ticker());
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_id());
  }

  // uint32 market_id = 3;
  if (this->_internal_market_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_market_id());
  }

  // sint32 atomic_resolution = 4;
  if (this->_internal_atomic_resolution() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_atomic_resolution());
  }

  // uint32 liquidity_tier = 5;
  if (this->_internal_liquidity_tier() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_liquidity_tier());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdatePerpetualEventV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdatePerpetualEventV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdatePerpetualEventV1::GetClassData() const { return &_class_data_; }


void UpdatePerpetualEventV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdatePerpetualEventV1*>(&to_msg);
  auto& from = static_cast<const UpdatePerpetualEventV1&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dydxprotocol.indexer.events.UpdatePerpetualEventV1)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ticker().empty()) {
    _this->_internal_set_ticker(from._internal_ticker());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_market_id() != 0) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (from._internal_atomic_resolution() != 0) {
    _this->_internal_set_atomic_resolution(from._internal_atomic_resolution());
  }
  if (from._internal_liquidity_tier() != 0) {
    _this->_internal_set_liquidity_tier(from._internal_liquidity_tier());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdatePerpetualEventV1::CopyFrom(const UpdatePerpetualEventV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dydxprotocol.indexer.events.UpdatePerpetualEventV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdatePerpetualEventV1::IsInitialized() const {
  return true;
}

void UpdatePerpetualEventV1::InternalSwap(UpdatePerpetualEventV1* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ticker_, lhs_arena,
                                       &other->_impl_.ticker_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdatePerpetualEventV1, _impl_.liquidity_tier_)
      + sizeof(UpdatePerpetualEventV1::_impl_.liquidity_tier_)
      - PROTOBUF_FIELD_OFFSET(UpdatePerpetualEventV1, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdatePerpetualEventV1::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_getter, &descriptor_table_dydxprotocol_2findexer_2fevents_2fevents_2eproto_once,
      file_level_metadata_dydxprotocol_2findexer_2fevents_2fevents_2eproto[22]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace events
}  // namespace indexer
}  // namespace dydxprotocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::FundingUpdateV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::FundingUpdateV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::FundingUpdateV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::FundingEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::FundingEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::FundingEventV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::MarketEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::MarketEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::MarketEventV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::MarketPriceUpdateEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::MarketPriceUpdateEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::MarketPriceUpdateEventV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::MarketBaseEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::MarketBaseEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::MarketBaseEventV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::MarketCreateEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::MarketCreateEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::MarketCreateEventV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::MarketModifyEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::MarketModifyEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::MarketModifyEventV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::SourceOfFunds*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::SourceOfFunds >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::SourceOfFunds >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::TransferEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::TransferEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::TransferEventV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::OrderFillEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::OrderFillEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::OrderFillEventV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::LiquidationOrderV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::LiquidationOrderV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::LiquidationOrderV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::SubaccountUpdateEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::SubaccountUpdateEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::SubaccountUpdateEventV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderPlacementV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderPlacementV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderPlacementV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderRemovalV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderRemovalV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::StatefulOrderEventV1_StatefulOrderRemovalV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderPlacementV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderPlacementV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderPlacementV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderTriggeredV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderTriggeredV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::StatefulOrderEventV1_ConditionalOrderTriggeredV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::StatefulOrderEventV1_LongTermOrderPlacementV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::StatefulOrderEventV1_LongTermOrderPlacementV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::StatefulOrderEventV1_LongTermOrderPlacementV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::StatefulOrderEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::StatefulOrderEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::StatefulOrderEventV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::AssetCreateEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::AssetCreateEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::AssetCreateEventV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::PerpetualMarketCreateEventV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::LiquidityTierUpsertEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::LiquidityTierUpsertEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::LiquidityTierUpsertEventV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::UpdateClobPairEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::UpdateClobPairEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::UpdateClobPairEventV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::dydxprotocol::indexer::events::UpdatePerpetualEventV1*
Arena::CreateMaybeMessage< ::dydxprotocol::indexer::events::UpdatePerpetualEventV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dydxprotocol::indexer::events::UpdatePerpetualEventV1 >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
